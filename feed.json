{
    "version": "https://jsonfeed.org/version/1",
    "title": "chriskali",
    "home_page_url": "https://chriskalix.github.io/",
    "feed_url": "https://chriskalix.github.io/feed.json",
    "description": "Security engineer.<br> Working on eBPF, Host Intrusion Detection System, WAF, and some Java Security.<br> Language: golang",
    "icon": "https://chriskalix.github.io/apple-touch-icon.png",
    "favicon": "https://chriskalix.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "chriskali",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            "title": "Linux Rootkit初窥(一)IDT",
            "summary": "Linux Rootkit初窥(一)IDT",
            "content_text": "背景近期在编写 HIDS 相关项目 - Hades，对于用户态的后门或者行为，由于使用了 eBPF 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 Rootkit 的一举一动。目前 Hades 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 uprobes，对于用户态后门、入侵行为等能有较全的感知。然而对于 Rootkit，由于笔者知识匮乏，除了 hook do_init_module 和针对 eBPF 程序加载（ebpfkit-monitor）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考基础知识  由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的回答中我们找到 phrack.org，开始学习。参考 Handling Interrupt Descriptor Table for fun and profit，很大一部分可能会是翻译，翻译的过程就是学习的过程首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 sys_call_table 地址也可以从 IDT 中获取什么是 IDT ?  IDT 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含三种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门为了方便理解，借用一个图(这图很经典，方便了解整个流程)：in Linux在 Linux 中，IDT 的定义在 arch/x86/kernel/idt.c ，IDT_ENTRIES 固定为 256gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;其中 gate_desc 定义如下struct gate_struct {    u16     offset_low;    u16     segment;    struct idt_bits bits;    u16     offset_middle;#ifdef CONFIG_X86_64    u32     offset_high;    u32     reserved;#endif} __attribute__((packed));从项目出发从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些项目。在 idt.c 中，通过替换 IDT 地址实现 Hook，关键代码如下：void idt_set_entry(unsigned long addr, int n){    if (cur_idt_table == old_idt_table)        set_addr_rw(old_idt_table);    cur_idt_table[n].offset_high = (addr &gt;&gt; 32) &amp; 0xffffffff;    cur_idt_table[n].offset_middle = (addr &gt;&gt; 16) &amp; 0xffff;    cur_idt_table[n].offset_low = addr &amp; 0xffff;    if (cur_idt_table == old_idt_table)        set_addr_ro(old_idt_table);}void idt_substitute(void){    struct desc_ptr idtr;    memcpy(new_idt_table, cur_idt_table, IDT_SZ);    idtr.address = (unsigned long)new_idt_table;    idtr.size = idt_size;    on_each_cpu(local_load_idt, &amp;idtr, 1);    cur_idt_table = new_idt_table;}替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 sys_call_table 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 sys_call_table 中的偏移…顺便贴一张 IDTR在字节的 anti_rootkit 中我们截取 interrupt 检查部分，事实上 sys_call_table 的检查部分也是一样的static void analyze_interrupts(void){#ifdef CONFIG_X86    int i;    unsigned long addr;    struct module *mod;    if (!idt || !ckt)        return;    // 遍历所有 entries    for (i = 0; i &lt; IDT_ENTRIES; i++) {        const char *mod_name = \"-1\";         addr = idt[i];        // ckt 判断是否为内核代码段        if (!ckt(addr)) {            module_list_lock();            // 获取 idt 对应函数的地址            mod = get_module_from_addr(addr);            if (mod) {                mod_name = mod-&gt;name;            } else {                // 寻找是否为隐藏的内核模块                // 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对                // 如果找不到，则为隐藏的内核模块，是可疑的                const char *name = find_hidden_module(addr);                if (IS_ERR_OR_NULL(name)) {                    module_list_unlock();                    continue;                }                mod_name = name;            }            interrupts_print(mod_name, i);            module_list_unlock();        }    }#endif}这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?最后其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进参考  有字节群中沈平推荐的两本，可以细细品读，我还没看…1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本3, nskernel-kernel-play-guide",
            "content_html": "<h2 id=\"背景\">背景</h2><p>近期在编写 HIDS 相关项目 - <a href=\"https://github.com/chriskaliX/Hades\">Hades</a>，对于用户态的后门或者行为，由于使用了 <code class=\"language-plaintext highlighter-rouge\">eBPF</code> 进行内核态的函数 Hook，我们能够发现大部分的行为。只要 Hook 的够全面，几乎能检测到用户层 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code> 的一举一动。目前 <code class=\"language-plaintext highlighter-rouge\">Hades</code> 项目完成了十余个 hook，覆盖了执行、网络等，后续补全文件侧以及常用的 <code class=\"language-plaintext highlighter-rouge\">uprobes</code>，对于用户态后门、入侵行为等能有较全的感知。然而对于 <code class=\"language-plaintext highlighter-rouge\">Rootkit</code>，由于笔者知识匮乏，除了 hook <code class=\"language-plaintext highlighter-rouge\">do_init_module</code> 和针对 eBPF 程序加载（<a href=\"https://github.com/Gui774ume/ebpfkit-monitor\">ebpfkit-monitor</a>）做监测，也不知道如何防范，抓取这样的行为…作为知识的补充，本篇文章涵盖 Rootkit/Linux 基础学习以及一些思考</p><h3 id=\"基础知识\">基础知识</h3><blockquote>  <p>由于之前对这部分一窍不通，好多的基础知识我们当作实验，稍微的过一遍。从知乎的<a href=\"https://www.zhihu.com/question/33695415\">回答</a>中我们找到 phrack.org，开始学习。参考 <a href=\"http://phrack.org/issues/59/4.html\">Handling Interrupt Descriptor Table for fun and profit</a>，很大一部分可能会是翻译，翻译的过程就是学习的过程</p></blockquote><p>首先，Intel CPU 在保护模式，提供四种模式，即 r0 ~ r3 层，用户层的应用程序一般运行在 r3 层，内核态的运行在 r0 层</p><p>中断分为可屏蔽和不可屏蔽中断，其中不可屏蔽中断在这里不讨论。中断向量是个0~255之间的数，其中 0~31 是 exceptions 以及不可屏蔽中断， 32~47 是可屏蔽中断，48~255 为软件中断。Linux 下通常使用的是 (0x80) sys_call_table，即用户态通过 syscall 调用到内核函数。同样的，当我们为了获取 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 地址也可以从 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 中获取</p><p>什么是 <code class=\"language-plaintext highlighter-rouge\">IDT</code> ?  <code class=\"language-plaintext highlighter-rouge\">IDT</code> 即 Interrupt Descriptor Table。是一个描述中断即其对应处理函数的线性表，包含三种不同类型的描述/类型。分别是 Task Gate Descriptor（Linux 不使用这种） / Interrupt Gate Descriptor / Trap Gate Descriptor</p><p>其中 Interrupt Gate Descriptor 用于中断的处理，需要关注的是 DPL（Descriptor Privilege Level）为0，因此用户态不能访问中断门</p><p>为了方便理解，借用一个图(这图很经典，方便了解整个流程)：</p><p><img src=\"https://chriskaliX.github.io/assets/imgs/callgraph.jpg\" alt=\"简书\" /></p><h4 id=\"in-linux\">in Linux</h4><p>在 Linux 中，IDT 的定义在 <code class=\"language-plaintext highlighter-rouge\">arch/x86/kernel/idt.c</code> ，<code class=\"language-plaintext highlighter-rouge\">IDT_ENTRIES</code> 固定为 256</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gate_desc</span> <span class=\"n\">idt_table</span><span class=\"p\">[</span><span class=\"n\">IDT_ENTRIES</span><span class=\"p\">]</span> <span class=\"n\">__page_aligned_bss</span><span class=\"p\">;</span></code></pre></div></div><p>其中 <code class=\"language-plaintext highlighter-rouge\">gate_desc</code> 定义如下</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">struct</span> <span class=\"n\">gate_struct</span> <span class=\"p\">{</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_low</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">segment</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">idt_bits</span> <span class=\"n\">bits</span><span class=\"p\">;</span>    <span class=\"n\">u16</span>     <span class=\"n\">offset_middle</span><span class=\"p\">;</span><span class=\"cp\">#ifdef CONFIG_X86_64</span>    <span class=\"n\">u32</span>     <span class=\"n\">offset_high</span><span class=\"p\">;</span>    <span class=\"n\">u32</span>     <span class=\"n\">reserved</span><span class=\"p\">;</span><span class=\"cp\">#endif</span><span class=\"p\">}</span> <span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">packed</span><span class=\"p\">));</span></code></pre></div></div><h3 id=\"从项目出发\">从项目出发</h3><p>从开始，我们便以字节的 Elkeid 作为参考。Elkeid 主要检查了 4 个，即隐藏内核模块/进程隐藏/IDT劫持/系统调用劫持。我们以 idt rootkit 为关键字，搜索到一些<a href=\"https://github.com/kaneschutzman/linux-rootkit\">项目</a>。在 <a href=\"https://github.com/kaneschutzman/linux-rootkit/blob/5dcb228a86f67773d6e2b92276e59cf030b52c23/src/idt.c\">idt.c</a> 中，通过替换 <code class=\"language-plaintext highlighter-rouge\">IDT</code> 地址实现 Hook，关键代码如下：</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">idt_set_entry</span><span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_rw</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_high</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">32</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffffffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_middle</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">addr</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"n\">cur_idt_table</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">].</span><span class=\"n\">offset_low</span> <span class=\"o\">=</span> <span class=\"n\">addr</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0xffff</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">cur_idt_table</span> <span class=\"o\">==</span> <span class=\"n\">old_idt_table</span><span class=\"p\">)</span>        <span class=\"n\">set_addr_ro</span><span class=\"p\">(</span><span class=\"n\">old_idt_table</span><span class=\"p\">);</span><span class=\"p\">}</span><span class=\"kt\">void</span> <span class=\"nf\">idt_substitute</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span>    <span class=\"k\">struct</span> <span class=\"n\">desc_ptr</span> <span class=\"n\">idtr</span><span class=\"p\">;</span>    <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">new_idt_table</span><span class=\"p\">,</span> <span class=\"n\">cur_idt_table</span><span class=\"p\">,</span> <span class=\"n\">IDT_SZ</span><span class=\"p\">);</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span><span class=\"n\">new_idt_table</span><span class=\"p\">;</span>    <span class=\"n\">idtr</span><span class=\"p\">.</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">idt_size</span><span class=\"p\">;</span>    <span class=\"n\">on_each_cpu</span><span class=\"p\">(</span><span class=\"n\">local_load_idt</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">idtr</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>    <span class=\"n\">cur_idt_table</span> <span class=\"o\">=</span> <span class=\"n\">new_idt_table</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p>替换表的形式来完成劫持，其中对 IDTR 寄存器的操作使用 LIDT 指令和 SIDT 指令。另外 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的 hook 应该方法也是类似，先在 IDT 表中找到 0x80 中断的位置，再根据特定 function 再 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 中的偏移…</p><p>顺便贴一张 IDTR</p><p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo9%2F3a4a1cf12b0940c3a8115008a28511bd.jpg&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650278847&amp;t=cec7d575642e0f888777f63f0507bee7\" alt=\"百度\" /></p><p>在字节的 <code class=\"language-plaintext highlighter-rouge\">anti_rootkit</code> 中我们截取 <code class=\"language-plaintext highlighter-rouge\">interrupt</code> 检查部分，事实上 <code class=\"language-plaintext highlighter-rouge\">sys_call_table</code> 的检查部分也是一样的</p><div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">analyze_interrupts</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"p\">{</span><span class=\"cp\">#ifdef CONFIG_X86</span>    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">addr</span><span class=\"p\">;</span>    <span class=\"k\">struct</span> <span class=\"n\">module</span> <span class=\"o\">*</span><span class=\"n\">mod</span><span class=\"p\">;</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">idt</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">)</span>        <span class=\"k\">return</span><span class=\"p\">;</span>    <span class=\"c1\">// 遍历所有 entries</span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">IDT_ENTRIES</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"s\">\"-1\"</span><span class=\"p\">;</span>         <span class=\"n\">addr</span> <span class=\"o\">=</span> <span class=\"n\">idt</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>        <span class=\"c1\">// ckt 判断是否为内核代码段</span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">ckt</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">))</span> <span class=\"p\">{</span>            <span class=\"n\">module_list_lock</span><span class=\"p\">();</span>            <span class=\"c1\">// 获取 idt 对应函数的地址</span>            <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">get_module_from_addr</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"p\">)</span> <span class=\"p\">{</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">-&gt;</span><span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"c1\">// 寻找是否为隐藏的内核模块</span>                <span class=\"c1\">// 通过遍历 ksets 下的 mod list，通过于 kobj 一一比对</span>                <span class=\"c1\">// 如果找不到，则为隐藏的内核模块，是可疑的</span>                <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">find_hidden_module</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">IS_ERR_OR_NULL</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">))</span> <span class=\"p\">{</span>                    <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>                    <span class=\"k\">continue</span><span class=\"p\">;</span>                <span class=\"p\">}</span>                <span class=\"n\">mod_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"p\">;</span>            <span class=\"p\">}</span>            <span class=\"n\">interrupts_print</span><span class=\"p\">(</span><span class=\"n\">mod_name</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">);</span>            <span class=\"n\">module_list_unlock</span><span class=\"p\">();</span>        <span class=\"p\">}</span>    <span class=\"p\">}</span><span class=\"cp\">#endif</span><span class=\"p\">}</span></code></pre></div></div><p>这种检测，对函数的 entry 做了足够的检测，但是如何检测 hook 在函数中间的情况呢?</p><h2 id=\"最后\">最后</h2><p>其实看的还是比较浅显的，如果每个模块都单独细钻，会耗费较大的时间，后续会慢慢跟进</p><h2 id=\"参考\">参考</h2><blockquote>  <p>有字节群中沈平推荐的两本，可以细细品读，我还没看…</p></blockquote><p>1, The Rootkit Arsenal Escape and Evasion in the Dark Corners of the System by Bill Blunden， 2nd edition，第一版是中译本</p><p>2, Rootkits and Bootkits Reversing Modern Malware and Next Generation Threats by Alex Matrosov, Eugene Rodionov, Sergey Bratus，有中译本</p><p>3, <a href=\"https://nskernel.gitbook.io/kernel-play-guide/hacking-interrupts-exceptions-and-trap-handlers/hooking-an-idt-handler\">nskernel-kernel-play-guide</a></p>",
            "url": "https://chriskalix.github.io/2022/03/19/linux-rootkit%E5%88%9D%E7%AA%A5-%E4%B8%80-idt",
            
            
            
            
            
            "date_published": "2022-03-19T00:00:00+01:00",
            "date_modified": "2022-03-19T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            "title": "从头开始的博客",
            "summary": "Gridea 用的不习惯",
            "content_text": "规划后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~",
            "content_html": "<h2 id=\"规划\">规划</h2><p>后续长期做的方向，应该还是 HIDS/WAF 反入侵相关。当然也会涉及 Java/Golang 的一些安全开发，这里将记录我的一切~</p>",
            "url": "https://chriskalix.github.io/2022/03/18/%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2",
            
            
            
            
            
            "date_published": "2022-03-18T00:00:00+01:00",
            "date_modified": "2022-03-18T00:00:00+01:00",
            
                "author":  {
                "name": "chriskali",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}